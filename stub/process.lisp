;;
;; convert alpha assembler lisp into C
;; I may never live this down, but I had to try it...
;;
;; Brad Parker 4/2006
;; brad@heeltoe.com
;;

(progn
  (defmacro unlock-package (pack)
    (setf *locked-package-saved-value* (ext:package-lock pack)
	  (ext:package-lock pack) nil))

  (unlock-package system)
  (unlock-package common-lisp)
  (unlock-package clos)
)

(unlock-package system)

(defpackage ALPHA-AXP-INTERNALS
  (:nicknames AXPI)
  (:use COMMON-LISP)
  (:shadow AND))

(defpackage I-LISP-COMPILER
  (:use COMMON-LISP)
  (:export *FINISH-CALL-N-OPCODE*))

(in-package "ALPHA-AXP-INTERNALS")

(defmacro lc (str)
  `(if (numberp ,str)
     ,str
    (string-downcase ,str)))

(defmacro defsubst (name arglist &body body)
   `(progn
      (declaim (inline ,name))
      (defun ,name ,arglist ,@body)))

(defmacro stack-let (vars-and-vals &body body)
   (let ((vars (loop for var-and-val in vars-and-vals
 		    if (atom var-and-val)
  		      collect var-and-val
 		    else
 		      collect (first var-and-val))))
     `(let ,vars-and-vals
        (declare (dynamic-extent ,@vars))
        ,@body)))

(defun circular-list (&rest list)
  (let ((list (copy-list list)))
    (setf (cdr (last list)) list)
    list))

(defmacro define-integer-register (name reg &rest other))

(defun register-asmname (name)
;  (format t "register-asmname: ~S~%" name)
  (lc name))

(defun find-register (name)
;  (format t "find-register: ~S~%" name)
  (lc name))

(in-package "SYSTEM")

(defun %logdpb (value bytespec integer)
  (let ((result (dpb value bytespec integer)))
     (if (zerop (ldb (byte 1 31) result))
	 result
       (- (ldb (byte 31 0) (1+ (lognot result)))))))

;;
(in-package "ALPHA-AXP-INTERNALS")

;; The function alignment is 3 so that calling into a new procedure
;; causes all a large number of the instructions following the initial
;; instruction to be read into the cache.
(defparameter *function-alignment* 5)

(defun coerce-to-register (reg)
  reg)

(defun coerce-to-register-or-literal (reglit)
  reglit)

(defun lsh (num places)
  (if (>= num 0) (ash num places)
    (if (>= places 0) (ash num places)
      (ash
       (logior
	(ash (logand -1 most-positive-fixnum) -1)
	(ash (+ most-positive-fixnum 1) -2)) (+ 1 places)))))

;;

(defun c-header (destination sourcename)
  (format destination
	  "~&/************************************************************************")
  (format destination
	  "~& * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED")
  (format destination
	  "~& * FROM ~a. ANY CHANGES MADE TO THIS FILE WILL BE LOST" sourcename)
  (format destination
	  "~& ************************************************************************/~%~%"))

(defun c-trailer (destination sourcename)
  (format destination
	  "~%~%~%/* End of file automatically generated from ~a */~%" sourcename))

(defvar *function-being-processed* nil)
(defvar *function-epilogue*)
(defvar *do-check-oflo* nil)
(defvar *do-check-ratquo* nil)

;
(defun macroexpand-careful (form env)
;  (format t "xxx: ~S~%" (car form))
  (if (eq (car form) 'AND)
      form
    (macroexpand form env)))

(defun macroexpand-asm-form (form &optional env)
  (if (consp (first form))
      (loop for meform in form
	    as expanded = (macroexpand-asm-form meform env)
	    if (consp (first expanded))
	      append expanded
	    else
	      collect expanded)
      (let ((expanded (macroexpand-careful form env)))
	(if (eq expanded form)
(progn
;(format t "macroexpand-asm-form: form ~S~%" form)
	    form
)
	    (macroexpand-asm-form expanded env)))))

(defun collecting-function-epilogue (body env)
  (let ((*function-epilogue* nil))
    `(,@(mapcar #'(lambda (x) (macroexpand-asm-form x env)) body)
      ,@(loop while *function-epilogue*
	      append (mapcar #'(lambda (x) (macroexpand-asm-form x env))
			     (shiftf *function-epilogue* nil))))))

;; (defmacro define-procedure (name (&rest args) &body body &environment env)
;;   (let ((*function-being-processed* name))
;;     `((start ,name ,(length args))
;; ;      (label ,name)
;;       (func-label ,name)
;;       ,@(collecting-function-epilogue body env)
;;       (end ,name))))

(defmacro check-comment (arg)
  `(if ,arg (format destination "  /* ~A */~%" ,arg)))

(defun remap-arg (str)
  (cdr (assoc str
	'((ICP . "iCP")
	  (IPC . "iPC")
	  (ISP . "iSP")
	  (IFP . "iFP")
	  (ILP . "iLP")
	  (ILP . "iLP")
	  (CACHELINE_NEXTPCDATA . "nextpcdata")
	  (CACHELINE_NEXTCP . "nextcp")
	  (CACHELINE_PCDATA . "pcdata")
	  (CACHELINE_INSTRUCTION . "instruction")
	  (CACHELINE_ANNOTATION . "annotation")
	  (CACHELINE_CODE . "code")
	  (CACHELINE_OPERAND . "operand")
	  (CACHELINESIZE . "CACHELINE_SIZE") ;

	  ;;--
	  (PROCESSORSTATE_TRANSPARE3 . "transpare3")
	  (PROCESSORSTATE_TRANSPARE2 . "transpare2")
	  (PROCESSORSTATE_TRANSPARE1 . "transpare1")
	  (PROCESSORSTATE_CARCDRSUBROUTINE . "carcdrsubroutine")
	  (PROCESSORSTATE_CDRSUBROUTINE . "cdrsubroutine")
	  (PROCESSORSTATE_CARSUBROUTINE . "carsubroutine")
	  (PROCESSORSTATE_LINKAGE . "linkage")
	  (PROCESSORSTATE_RESUMEEMA . "resumeema")
	  (PROCESSORSTATE_STATISTICS . "statistics")
	  (PROCESSORSTATE_TRACE_HOOK . "trace_hook")
	  (PROCESSORSTATE_INSTRUCTION_COUNT . "instruction_count")
	  (PROCESSORSTATE_LONG_PAD0 . "long_pad0")
	  (PROCESSORSTATE_ASRR9 . "asrr9")
	  (PROCESSORSTATE_ASRR10 . "asrr10")
	  (PROCESSORSTATE_ASRR11 . "asrr11")
	  (PROCESSORSTATE_ASRR12 . "asrr12")
	  (PROCESSORSTATE_ASRR13 . "asrr13")
	  (PROCESSORSTATE_ASRR14 . "asrr14")
	  (PROCESSORSTATE_ASRR15 . "asrr15")
	  (PROCESSORSTATE_LONG_PAD1 . "long_pad1")
	  (PROCESSORSTATE_ASRR26 . "asrr26")
	  (PROCESSORSTATE_ASRR27 . "asrr27")
	  (PROCESSORSTATE_ASRR29 . "asrr29")
	  (PROCESSORSTATE_ASRR30 . "asrr30")
	  (PROCESSORSTATE_ASRF2 . "asrf2")
	  (PROCESSORSTATE_ASRF3 . "asrf3")
	  (PROCESSORSTATE_ASRF4 . "asrf4")
	  (PROCESSORSTATE_ASRF5 . "asrf5")
	  (PROCESSORSTATE_ASRF6 . "asrf6")
	  (PROCESSORSTATE_ASRF7 . "asrf7")
	  (PROCESSORSTATE_ASRF8 . "asrf8")
	  (PROCESSORSTATE_ASRF9 . "asrf9")
	  (PROCESSORSTATE_METERDATABUFF . "meterdatabuff")
	  (PROCESSORSTATE_METERPOS . "meterpos")
	  (PROCESSORSTATE_METERMAX . "metermax")
	  (PROCESSORSTATE_METERFREQ . "meterfreq")
	  (PROCESSORSTATE_METERMASK . "metermask")
	  (PROCESSORSTATE_METERVALUE . "metervalue")
	  (PROCESSORSTATE_METERCOUNT . "metercount")
	  (PROCESSORSTATE_CHOICEPTR . "choiceptr")
	  (PROCESSORSTATE_SSTKCHOICEPTR . "sstkchoiceptr")
	  (PROCESSORSTATE_DBCBASE . "dbcbase")
	  (PROCESSORSTATE_DBCMASK . "dbcmask")
	  (PROCESSORSTATE_COPROCESSORREADHOOK . "coprocessorreadhook")
	  (PROCESSORSTATE_COPROCESSORWRITEHOOK . "coprocessorwritehook")
	  (PROCESSORSTATE_FLUSHCACHES_HOOK . "flushcaches_hook")
	  (PROCESSORSTATE_I_STAGE_ERROR_HOOK . "i_stage_error_hook")
	  (PROCESSORSTATE_SFP1 . "sfp1")
	  (PROCESSORSTATE_FP0 . "fp0")
	  (PROCESSORSTATE_FP1 . "fp1")
	  (PROCESSORSTATE_FLOATING_EXCEPTION . "floating_exception")
	  (PROCESSORSTATE_ALUANDROTATECONTROL . "aluandrotatecontrol")
	  (PROCESSORSTATE_ROTATELATCH . "rotatelatch")
	  (PROCESSORSTATE_ALUBORROW . "aluborrow")
	  (PROCESSORSTATE_ALUOVERFLOW . "aluoverflow")
	  (PROCESSORSTATE_ALULESSTHAN . "alulessthan")
	  (PROCESSORSTATE_ALUOP . "aluop")
	  (PROCESSORSTATE_BYTEROTATE . "byterotate")
	  (PROCESSORSTATE_BYTESIZE . "bytesize")
	  (PROCESSORSTATE_BINDINGSTACKLIMIT . "bindingstacklimit")
	  (PROCESSORSTATE_BINDINGSTACKPOINTER . "bindingstackpointer")
	  (PROCESSORSTATE_CATCHBLOCK . "catchblock")
	  (PROCESSORSTATE_EXTRAANDCATCH . "extraandcatch")
	  (PROCESSORSTATE_MSCLOCKCACHE . "msclockcache")
	  (PROCESSORSTATE_MSCMULTIPLIER . "mscmultiplier")
	  (PROCESSORSTATE_PREVIOUSRCPP . "previousrcpp")
	  (PROCESSORSTATE_RLINK . "rlink")
	  (PROCESSORSTATE_INTERRUPTREG . "interruptreg")
	  (PROCESSORSTATE_ZONEOLDSPACE . "zoneoldspace")
	  (PROCESSORSTATE_EPHEMERALOLDSPACE . "ephemeraloldspace")
	  (PROCESSORSTATE_INT_PAD0 . "int_pad0")
	  (PROCESSORSTATE_EQNOTEQL . "eqnoteql")
	  (PROCESSORSTATE_LCLENGTH . "lclength")
	  (PROCESSORSTATE_SCLENGTH . "sclength")
	  (PROCESSORSTATE_LCAREA . "lcarea")
	  (PROCESSORSTATE_LCADDRESS . "lcaddress")
	  (PROCESSORSTATE_SCAREA . "scarea")
	  (PROCESSORSTATE_SCADDRESS . "scaddress")
	  (PROCESSORSTATE_RESTARTSP . "restartsp")
	  (PROCESSORSTATE_STOP_INTERPRETER . "stop_interpreter")
	  (PROCESSORSTATE_IMMEDIATE_ARG . "immediate_arg")
	  (PROCESSORSTATE_CONTINUATIONCP . "continuationcp")
	  (PROCESSORSTATE_CONTINUATION . "continuation")
	  (PROCESSORSTATE_CONTROL . "control")
	  (PROCESSORSTATE_NILADDRESS . "niladdress")
	  (PROCESSORSTATE_TADDRESS . "taddress")
	  (PROCESSORSTATE_BAR0 . "bar0")
	  (PROCESSORSTATE_BAR1 . "bar1")
	  (PROCESSORSTATE_BAR2 . "bar2")
	  (PROCESSORSTATE_BAR3 . "bar3")
	  (PROCESSORSTATE_EPC . "epc")
	  (PROCESSORSTATE_FP . "fp")
	  (PROCESSORSTATE_LP . "lp")
	  (PROCESSORSTATE_SP . "sp")
	  (PROCESSORSTATE_CP . "cp")
	  (PROCESSORSTATE_FCCRMASK . "fccrmask")
	  (PROCESSORSTATE_CSLIMIT . "cslimit")
	  (PROCESSORSTATE_CSEXTRALIMIT . "csextralimit")
	  (PROCESSORSTATE_TRAPMETERDATA . "trapmeterdata")
	  (PROCESSORSTATE_FEPMODETRAPVECADDRESS . "fepmodetrapvecaddress")
	  (PROCESSORSTATE_TRAPVECBASE . "trapvecbase")
	  (PROCESSORSTATE_TVI . "tvi")
	  (PROCESSORSTATE_FCCRTRAPMASK . "fccrtrapmask")
	  (PROCESSORSTATE_PTRTYPE . "ptrtype")
	  (PROCESSORSTATE_VMATTRIBUTETABLE . "vmattributetable")
	  (PROCESSORSTATE_VMA . "vma")
	  (PROCESSORSTATE_MOSTNEGATIVEFIXNUM . "mostnegativefixnum")
	  (PROCESSORSTATE_ICACHEBASE . "icachebase")
	  (PROCESSORSTATE_ENDICACHE . "endicache")
	  (PROCESSORSTATE_FULLWORDDISPATCH . "fullworddispatch")
	  (PROCESSORSTATE_HALFWORDDISPATCH . "halfworddispatch")
	  (PROCESSORSTATE_AREVENTCOUNT . "areventcount")
	  (PROCESSORSTATE_STACKCACHESIZE . "stackcachesize")
	  (PROCESSORSTATE_STACKCACHETOPVMA . "stackcachetopvma")
	  (PROCESSORSTATE_CDRCODEMASK . "cdrcodemask")
	  (PROCESSORSTATE_STACKCACHEDATA . "stackcachedata")
	  (PROCESSORSTATE_STACKCACHEBASEVMA . "stackcachebasevma")
	  (PROCESSORSTATE_SCOVLIMIT . "scovlimit")
	  (PROCESSORSTATE_SCOVDUMPCOUNT . "scovdumpcount")
	  (PROCESSORSTATE_MOSTPOSITIVEFIXNUM . "mostpositivefixnum")
	  (PROCESSORSTATE_INTERNALREGISTERREAD1 . "internalregisterread1")
	  (PROCESSORSTATE_INTERNALREGISTERREAD2 . "internalregisterread2")
	  (PROCESSORSTATE_INTERNALREGISTERWRITE1 . "internalregisterwrite1")
	  (PROCESSORSTATE_INTERNALREGISTERWRITE2 . "internalregisterwrite2")
	  (PROCESSORSTATE_DATAREAD_MASK . "dataread_mask")
	  (PROCESSORSTATE_DATAREAD . "dataread")
	  (PROCESSORSTATE_DATAWRITE_MASK . "datawrite_mask")
	  (PROCESSORSTATE_DATAWRITE . "datawrite")
	  (PROCESSORSTATE_BINDREAD_MASK . "bindread_mask")
	  (PROCESSORSTATE_BINDREAD . "bindread")
	  (PROCESSORSTATE_BINDWRITE_MASK . "bindwrite_mask")
	  (PROCESSORSTATE_BINDWRITE . "bindwrite")
	  (PROCESSORSTATE_BINDREADNOMONITOR_MASK . "bindreadnomonitor_mask")
	  (PROCESSORSTATE_BINDREADNOMONITOR . "bindreadnomonitor")
	  (PROCESSORSTATE_BINDWRITENOMONITOR_MASK . "bindwritenomonitor_mask")
	  (PROCESSORSTATE_BINDWRITENOMONITOR . "bindwritenomonitor")
	  (PROCESSORSTATE_HEADER_MASK . "header_mask")
	  (PROCESSORSTATE_HEADER . "header")
	  (PROCESSORSTATE_STRUCTUREOFFSET_MASK . "structureoffset_mask")
	  (PROCESSORSTATE_STRUCTUREOFFSET . "structureoffset")
	  (PROCESSORSTATE_SCAVENGE_MASK . "scavenge_mask")
	  (PROCESSORSTATE_SCAVENGE . "scavenge")
	  (PROCESSORSTATE_CDR_MASK . "cdr_mask")
	  (PROCESSORSTATE_CDR . "cdr")
	  (PROCESSORSTATE_GCCOPY_MASK . "gccopy_mask")
	  (PROCESSORSTATE_GCCOPY . "gccopy")
	  (PROCESSORSTATE_RAW_MASK . "raw_mask")
	  (PROCESSORSTATE_RAW . "raw")
	  (PROCESSORSTATE_RAWTRANSLATE_MASK . "rawtranslate_mask")
	  (PROCESSORSTATE_RAWTRANSLATE . "rawtranslate")
	  (PROCESSORSTATE_PLEASE_STOP . "please_stop")
	  (PROCESSORSTATE_PLEASE_TRAP . "please_trap")
	  (PROCESSORSTATE_RUNNINGP . "runningp")
	  (PROCESSORSTATE_AC0ARRAY . "ac0array")
	  (PROCESSORSTATE_AC0ARWORD . "ac0arword")
	  (PROCESSORSTATE_AC0LOCAT . "ac0locat")
	  (PROCESSORSTATE_AC0LENGTH . "ac0length")
	  (PROCESSORSTATE_AC1ARRAY . "ac1array")
	  (PROCESSORSTATE_AC1ARWORD . "ac1arword")
	  (PROCESSORSTATE_AC1LOCAT . "ac1locat")
	  (PROCESSORSTATE_AC1LENGTH . "ac1length")
	  (PROCESSORSTATE_AC2ARRAY . "ac2array")
	  (PROCESSORSTATE_AC2ARWORD . "ac2arword")
	  (PROCESSORSTATE_AC2LOCAT . "ac2locat")
	  (PROCESSORSTATE_AC2LENGTH . "ac2length")
	  (PROCESSORSTATE_AC3ARRAY . "ac3array")
	  (PROCESSORSTATE_AC3ARWORD . "ac3arword")
	  (PROCESSORSTATE_AC3LOCAT . "ac3locat")
	  (PROCESSORSTATE_AC3LENGTH . "ac3length")
	  (PROCESSORSTATE_AC4ARRAY . "ac4array")
	  (PROCESSORSTATE_AC4ARWORD . "ac4arword")
	  (PROCESSORSTATE_AC4LOCAT . "ac4locat")
	  (PROCESSORSTATE_AC4LENGTH . "ac4length")
	  (PROCESSORSTATE_AC5ARRAY . "ac5array")
	  (PROCESSORSTATE_AC5ARWORD . "ac5arword")
	  (PROCESSORSTATE_AC5LOCAT . "ac5locat")
	  (PROCESSORSTATE_AC5LENGTH . "ac5length")
	  (PROCESSORSTATE_AC6ARRAY . "ac6array")
	  (PROCESSORSTATE_AC6ARWORD . "ac6arword")
	  (PROCESSORSTATE_AC6LOCAT . "ac6locat")
	  (PROCESSORSTATE_AC6LENGTH . "ac6length")
	  (PROCESSORSTATE_AC7ARRAY . "ac7array")
	  (PROCESSORSTATE_AC7ARWORD . "ac7arword")
	  (PROCESSORSTATE_AC7LOCAT . "ac7locat")
	  (PROCESSORSTATE_AC7LENGTH . "ac7length")
	  (PROCESSORSTATE_TMCURRENTTRANSACTION . "tmcurrenttransaction")
	  (PROCESSORSTATE_TMWRITESTART . "tmwritestart")
	  (PROCESSORSTATE_TMWRITECURRENT . "tmwritecurrent")
	  (PROCESSORSTATE_TMWRITELIMIT . "tmwritelimit")
	  (PROCESSORSTATE_TMRECORDINGREADS . "tmrecordingreads")
	  (PROCESSORSTATE_TMREADSTART . "tmreadstart")
	  (PROCESSORSTATE_TMREADCURRENT . "tmreadcurrent")
	  (PROCESSORSTATE_TMREADLIMIT . "tmreadlimit")
	  ;;--

	  (|Opcode_DoubleFloatOp| . "Opcode_DoubleFloatOp")
	  (arraycache_array . "array")
	  (arraycache_arword . "arword")
	  (arraycache_locat . "locat")
	  (arraycache_length . "length")

	  (CACHELINERSHIFT . "CacheLine_RShift")
	  (CACHELINELSHIFT . "CacheLine_LShift")

	  (|CacheLineRShift| . "CacheLine_RShift")
	  (|CacheLineLShift| . "CacheLine_LShift")

	  ("CacheLineRShift" . "CacheLine_RShift")
	  ("CacheLineLShift" . "CacheLine_LShift")

	  (|MemoryActionIndirect| . "MemoryActionIndirect")
	  (|MemoryActionMonitor| . "MemoryActionMonitor")
	  (|MemoryActionTransport| . "MemoryActionTransport")
	  (|MemoryActionTrap| . "MemoryActionTrap")
	  (|MemoryActionTransform| . "MemoryActionTransform")
	  (|MemoryActionBinding| . "MemoryActionBinding")

	  (|MemoryPageSize| . "MemoryPage_Size")
	  (|MemoryPageAddressShift| . "MemoryPage_AddressShift")

	  (|VMAttributeAccessFault| . "VMAttribute_AccessFault")
	  (|VMAttributeWriteFault| . "VMAttribute_WriteFault")
	  (|VMAttributeTransportFault| . "VMAttribute_TransportFault")
	  (|VMAttributeTransportDisable| . "VMAttribute_TransportDisable")
	  (|VMAttributeEphemeral| . "VMAttribute_Ephemeral")
	  (|VMAttributeModified| . "VMAttribute_Modified")
	  (|VMAttributeExists| . "VMAttribute_Exists")
	  (|VMAttributeCreatedDefault| . "VMAttribute_CreatedDefault")


	  (twocachelinesize . "TWOCACHELINESIZE")
	  (fourcachelinesize . "FOURCACHELINESIZE")

	  ;;--
	  (|TypeNull| . "Type_Null")
	  (|TypeMonitorForward| . "Type_MonitorForward")
	  (|TypeHeaderP| . "Type_HeaderP")
	  (|TypeHeaderI| . "Type_HeaderI")
	  (|TypeExternalValueCellPointer| . "Type_ExternalValueCellPointer")
	  (|TypeOneQForward| . "Type_OneQForward")
	  (|TypeHeaderForward| . "Type_HeaderForward")
	  (|TypeElementForward| . "Type_ElementForward")
	  (|TypeFixnum| . "Type_Fixnum")
	  (|TypeSmallRatio| . "Type_SmallRatio")
	  (|TypeSingleFloat| . "Type_SingleFloat")
	  (|TypeDoubleFloat| . "Type_DoubleFloat")
	  (|TypeBignum| . "Type_Bignum")
	  (|TypeBigRatio| . "Type_BigRatio")
	  (|TypeComplex| . "Type_Complex")
	  (|TypeSpareNumber| . "Type_SpareNumber")
	  (|TypeInstance| . "Type_Instance")
	  (|TypeListInstance| . "Type_ListInstance")
	  (|TypeArrayInstance| . "Type_ArrayInstance")
	  (|TypeStringInstance| . "Type_StringInstance")
	  (|TypeNIL| . "Type_NIL")
	  (|TypeList| . "Type_List")
	  (|TypeArray| . "Type_Array")
	  (|TypeString| . "Type_String")
	  (|TypeSymbol| . "Type_Symbol")
	  (|TypeLocative| . "Type_Locative")
	  (|TypeLexicalClosure| . "Type_LexicalClosure")
	  (|TypeDynamicClosure| . "Type_DynamicClosure")
	  (|TypeCompiledFunction| . "Type_CompiledFunction")
	  (|TypeGenericFunction| . "Type_GenericFunction")
	  (|TypeSparePointer1| . "Type_SparePointer1")
	  (|TypeSparePointer2| . "Type_SparePointer2")
	  (|TypePhysicalAddress| . "Type_PhysicalAddress")
	  (|TypeNativeInstruction| . "Type_NativeInstruction")
	  (|TypeBoundLocation| . "Type_BoundLocation")
	  (|TypeCharacter| . "Type_Character")
	  (|TypeLogicVariable| . "Type_LogicVariable")
	  (|TypeGCForward| . "Type_GCForward")
	  (|TypeEvenPC| . "Type_EvenPC")
	  (|TypeOddPC| . "Type_OddPC")
	  (|TypeCallCompiledEven| . "Type_CallCompiledEven")
	  (|TypeCallCompiledOdd| . "Type_CallCompiledOdd")
	  (|TypeCallIndirect| . "Type_CallIndirect")
	  (|TypeCallGeneric| . "Type_CallGeneric")
	  (|TypeCallCompiledEvenPrefetch| . "Type_CallCompiledEvenPrefetch")
	  (|TypeCallCompiledOddPrefetch| . "Type_CallCompiledOddPrefetch")
	  (|TypeCallIndirectPrefetch| . "Type_CallIndirectPrefetch")
	  (|TypeCallGenericPrefetch| . "Type_CallGenericPrefetch")
	  (|TypePackedInstruction60| . "Type_PackedInstruction60")
	  (|TypeTypePackedInstruction61| . "Type_TypePackedInstruction61")
	  (|TypeTypePackedInstruction62| . "Type_TypePackedInstruction62")
	  (|TypePackedInstruction63| . "Type_PackedInstruction63")
	  (|TypeTypePackedInstruction64| . "Type_TypePackedInstruction64")
	  (|TypeTypePackedInstruction65| . "Type_TypePackedInstruction65")
	  (|TypePackedInstruction66| . "Type_PackedInstruction66")
	  (|TypeTypePackedInstruction67| . "Type_TypePackedInstruction67")
	  (|TypeTypePackedInstruction70| . "Type_TypePackedInstruction70")
	  (|TypePackedInstruction71| . "Type_PackedInstruction71")
	  (|TypeTypePackedInstruction72| . "Type_TypePackedInstruction72")
	  (|TypeTypePackedInstruction73| . "Type_TypePackedInstruction73")
	  (|TypePackedInstruction74| . "Type_PackedInstruction74")
	  (|TypeTypePackedInstruction75| . "Type_TypePackedInstruction75")
	  (|TypeTypePackedInstruction76| . "Type_TypePackedInstruction76")
	  (|TypePackedInstruction77| . "Type_PackedInstruction77")
	  ;;--

	  (|ArrayElementTypeFixnum| . "Array_ElementTypeFixnum")
	  (|ArrayElementTypeCharacter| . "Array_ElementTypeCharacter")
	  (|ArrayElementTypeBoolean| . "Array_ElementTypeBoolean")
	  (|ArrayElementTypeObject| . "Array_ElementTypeObject")
	  (|ArrayTypeFieldPos| . "Array_TypeFieldPos")
	  (|ArrayTypeFieldSize| . "Array_TypeFieldSize")
	  (|ArrayTypeFieldMask| . "Array_TypeFieldMask")
	  (|ArrayElementTypePos| . "Array_ElementTypePos")
	  (|ArrayElementTypeSize| . "Array_ElementTypeSize")
	  (|ArrayElementTypeMask| . "Array_ElementTypeMask")
	  (|ArrayBytePackingPos| . "Array_BytePackingPos")
	  (|ArrayBytePackingSize| . "Array_BytePackingSize")
	  (|ArrayBytePackingMask| . "Array_BytePackingMask")
	  (|ArrayListBitPos| . "Array_ListBitPos")
	  (|ArrayListBitSize| . "Array_ListBitSize")
	  (|ArrayListBitMask| . "Array_ListBitMask")
	  (|ArrayNamedStructureBitPos| . "Array_NamedStructureBitPos")
	  (|ArrayNamedStructureBitSize| . "Array_NamedStructureBitSize")
	  (|ArrayNamedStructureBitMask| . "Array_NamedStructureBitMask")
	  (|ArraySpare1Pos| . "Array_Spare1Pos")
	  (|ArraySpare1Size| . "Array_Spare1Size")
	  (|ArraySpare1Mask| . "Array_Spare1Mask")
	  (|ArrayLongPrefixBitPos| . "Array_LongPrefixBitPos")
	  (|ArrayLongPrefixBitSize| . "Array_LongPrefixBitSize")
	  (|ArrayLongPrefixBitMask| . "Array_LongPrefixBitMask")
	  (|ArrayLeaderLengthFieldPos| . "Array_LeaderLengthFieldPos")
	  (|ArrayLeaderLengthFieldSize| . "Array_LeaderLengthFieldSize")
	  (|ArrayLeaderLengthFieldMask| . "Array_LeaderLengthFieldMask")
	  (|ArrayLengthPos| . "Array_LengthPos")
	  (|ArrayLengthSize| . "Array_LengthSize")
	  (|ArrayLengthMask| . "Array_LengthMask")
	  (|ArrayDisplacedBitPos| . "Array_DisplacedBitPos")
	  (|ArrayDisplacedBitSize| . "Array_DisplacedBitSize")
	  (|ArrayDisplacedBitMask| . "Array_DisplacedBitMask")
	  (|ArrayDiscontiguousBitPos| . "Array_DiscontiguousBitPos")
	  (|ArrayDiscontinuousBitSize| . "Array_DiscontinuousBitSize")
	  (|ArrayDiscontiguousBitMask| . "Array_DiscontiguousBitMask")
	  (|ArrayLongSparePos| . "Array_LongSparePos")
	  (|ArrayLongSpareSize| . "Array_LongSpareSize")
	  (|ArrayLongSpareMask| . "Array_LongSpareMask")
	  (|ArrayLongDimensionsFieldPos| . "Array_LongDimensionsFieldPos")
	  (|ArrayLongDimensionsFieldSize| . "Array_LongDimensionsFieldSize")
	  (|ArrayLongDimensionsFieldMask| . "Array_LongDimensionsFieldMask")
	  (|ArrayRegisterElementTypePos| . "Array_RegisterElementTypePos")
	  (|ArrayRegisterElementTypeSize| . "Array_RegisterElementTypeSize")
	  (|ArrayRegisterElementTypeMask| . "Array_RegisterElementTypeMask")
	  (|ArrayRegisterBytePackingPos| . "Array_RegisterBytePackingPos")
	  (|ArrayRegisterBytePackingSize| . "Array_RegisterBytePackingSize")
	  (|ArrayRegisterBytePackingMask| . "Array_RegisterBytePackingMask")
	  (|ArrayRegisterByteOffsetPos| . "Array_RegisterByteOffsetPos")
	  (|ArrayRegisterByteOffsetSize| . "Array_RegisterByteOffsetSize")
	  (|ArrayRegisterByteOffsetMask| . "Array_RegisterByteOffsetMask")
	  (|ArrayRegisterEventCountPos| . "Array_RegisterEventCountPos")
	  (|ArrayRegisterEventCountSize| . "Array_RegisterEventCountSize")
	  (|ArrayRegisterEventCountMask| . "Array_RegisterEventCountMask")

	  (|AutoArrayRegMask| . "AutoArrayRegMask")
	  (|AutoArrayRegSize| . "AutoArrayRegSize")
	  (|AutoArrayRegShift| . "AutoArrayRegShift")

	  (|CdrNext| . "Cdr_Next")
	  (|CdrNil| . "Cdr_Nil")
	  (|CdrNormal| . "Cdr_Normal")

	  (|ReturnValueNormal| . "ReturnValue_Normal")
	  (|ReturnValueException| . "ReturnValue_Exception")
	  (|ReturnValueIllegalOperand| . "ReturnValue_IllegalOperand")

	  (|ALUFunctionBoolean| . "ALUFunction_Boolean")
	  (|ALUFunctionByte| . "ALUFunction_Byte")
	  (|ALUFunctionAdder| . "ALUFunction_Adder")
	  (|ALUFunctionMultiplyDivide| . "ALUFunction_MultiplyDivide")

	  (|ALUConditionSignedLessThanOrEqual| . "ALUCondition_SignedLessThanOrEqual")
	  (|ALUConditionSignedLessThan| . "ALUCondition_SignedLessThan")
	  (|ALUConditionNegative| . "ALUCondition_Negative")
	  (|ALUConditionSignedOverflow| . "ALUCondition_SignedOverflow")
	  (|ALUConditionUnsignedLessThanOrEqual| . "ALUCondition_UnsignedLessThanOrEqual")
	  (|ALUConditionUnsignedLessThan| . "ALUCondition_UnsignedLessThan")
	  (|ALUConditionZero| . "ALUCondition_Zero")
	  (|ALUConditionHigh25Zero| . "ALUCondition_High25Zero")
	  (|ALUConditionEq| . "ALUCondition_Eq")
	  (|ALUConditionOp1Ephemeralp| . "ALUCondition_Op1Ephemeralp")
	  (|ALUConditionOp1TypeAcceptable| . "ALUCondition_Op1TypeAcceptable")
	  (|ALUConditionOp1TypeCondition| . "ALUCondition_Op1TypeCondition")
	  (|ALUConditionResultTypeNil| . "ALUCondition_ResultTypeNil")
	  (|ALUConditionOp2Fixnum| . "ALUCondition_Op2Fixnum")
	  (|ALUConditionFalse| . "ALUCondition_False")
	  (|ALUConditionResultCdrLow| . "ALUCondition_ResultCdrLow")
	  (|ALUConditionCleanupBitsSet| . "ALUCondition_CleanupBitsSet")
	  (|ALUConditionAddressInStackCache| . "ALUCondition_AddressInStackCache")
	  (|ALUConditionPendingSequenceBreakEnabled| . "ALUCondition_PendingSequenceBreakEnabled")
	  (|ALUConditionExtraStackMode| . "ALUCondition_ExtraStackMode")
	  (|ALUConditionFepMode| . "ALUCondition_FepMode")
	  (|ALUConditionFpCoprocessorPresent| . "ALUCondition_FpCoprocessorPresent")
	  (|ALUConditionOp1Oldspacep| . "ALUCondition_Op1Oldspacep")
	  (|ALUConditionStackCacheOverflow| . "ALUCondition_StackCacheOverflow")
	  (|ALUConditionOrLogicVariable| . "ALUCondition_OrLogicVariable")
	  (|ALUAdderOp2Op2| . "ALUAdderOp2_Op2")
	  (|ALUAdderOp2Zero| . "ALUAdderOp2_Zero")
	  (|ALUAdderOp2Invert| . "ALUAdderOp2_Invert")
	  (|ALUAdderOp2MinusOne| . "ALUAdderOp2_MinusOne")
	  (|ALUByteFunctionDpb| . "ALUByteFunction_Dpb")
	  (|ALUByteFunctionLdb| . "ALUByteFunction_Ldb")
	  (|ALUByteBackgroundOp1| . "ALUByteBackground_Op1")
	  (|ALUByteBackgroundRotateLatch| . "ALUByteBackground_RotateLatch")
	  (|ALUByteBackgroundZero| . "ALUByteBackground_Zero")

	  (|BooleClear| . "Boole_Clear")
	  (|BooleAnd| . "Boole_And")
	  (|BooleAndC1| . "Boole_AndC1")
	  (|Boole2| . "Boole_2")
	  (|BooleAndC2| . "Boole_AndC2")
	  (|Boole1| . "Boole_1")
	  (|BooleXor| . "Boole_Xor")
	  (|BooleIor| . "Boole_Ior")
	  (|BooleNor| . "Boole_Nor")
	  (|BooleEquiv| . "Boole_Equiv")
	  (|BooleC1| . "Boole_C1")
	  (|BooleOrC1| . "Boole_OrC1")
	  (|BooleC2| . "Boole_C2")
	  (|BooleOrC2| . "Boole_OrC2")
	  (|BooleNand| . "Boole_Nand")
	  (|BooleSet| . "Boole_Set")

	  (|CoprocessorRegisterUnwindStackForRestartOrApply| . "CoprocessorRegister_UnwindStackForRestartOrApply")
	  (|CoprocessorRegisterFlushIDCaches| . "CoprocessorRegister_FlushIDCaches")
	  (|CoprocessorRegisterFlushCachesForVMA| . "CoprocessorRegister_FlushCachesForVMA")
	  (|CoprocessorRegisterFlushHiddenArrayRegisters| . "CoprocessorRegister_FlushHiddenArrayRegisters")

	  (|CycleDataRead| . "Cycle_DataRead")
	  (|CycleDataWrite| . "Cycle_DataWrite")
	  (|CycleBindRead| . "Cycle_BindRead")
	  (|CycleBindWrite| . "Cycle_BindWrite")
	  (|CycleBindReadNoMonitor| . "Cycle_BindReadNoMonitor")
	  (|CycleBindWriteNoMonitor| . "Cycle_BindWriteNoMonitor")
	  (|CycleHeader| . "Cycle_Header")
	  (|CycleStructureOffset| . "Cycle_StructureOffset")
	  (|CycleScavenge| . "Cycle_Scavenge")
	  (|CycleCdr| . "Cycle_Cdr")
	  (|CycleGCCopy| . "Cycle_GCCopy")
	  (|CycleRaw| . "Cycle_Raw")
	  (|CycleRawTranslate| . "Cycle_RawTranslate")

	  (|TrapVectorArithmeticInstructionException| . "TrapVector_ArithmeticInstructionException")
	  (|TrapVectorStackOverflow| . "TrapVector_StackOverflow")
	  (|TrapVectorInstructionException| . "TrapVector_InstructionException")
	  (|TrapVectorError| . "TrapVector_Error")
	  (|TrapVectorReset| . "TrapVector_Reset")
	  (|TrapVectorPullApplyArgs| . "TrapVector_PullApplyArgs")
	  (|TrapVectorTrace| . "TrapVector_Trace")
	  (|TrapVectorPreemptRequest| . "TrapVector_PreemptRequest")
	  (|TrapVectorLowPrioritySequenceBreak| . "TrapVector_LowPrioritySequenceBreak")
	  (|TrapVectorHighPrioritySequenceBreak| . "TrapVector_HighPrioritySequenceBreak")
	  (|TrapVectorDBUnwindFrame| . "TrapVector_DBUnwindFrame")
	  (|TrapVectorDBUnwindCatch| . "TrapVector_DBUnwindCatch")
	  (|TrapVectorTransport| . "TrapVector_Transport")
	  (|TrapVectorMonitor| . "TrapVector_Monitor")
	  (|TrapVectorPageNotResident| . "TrapVector_PageNotResident")
	  (|TrapVectorPageFaultRequest| . "TrapVector_PageFaultRequest")
	  (|TrapVectorPageWriteFault| . "TrapVector_PageWriteFault")
	  (|TrapVectorUncorrectableMemoryError| . "TrapVector_UncorrectableMemoryError")
	  (|TrapVectorMemoryBusError| . "TrapVector_MemoryBusError")

	  (|ValueDispositionEffect| . "ValueDisposition_Effect")
	  (|ValueDispositionValue| . "ValueDisposition_Value")
	  (|ValueDispositionReturn| . "ValueDisposition_Return")
	  (|ValueDispositionMultiple| . "ValueDisposition_Multiple")

	  (|TrapReasonHighPrioritySequenceBreak| . "TrapReason_HighPrioritySequenceBreak")
	  (|TrapReasonLowPrioritySequenceBreak| . "TrapReason_LowPrioritySequenceBreak")

	  (|TrapModeEmulator| . "TrapMode_Emulator")
	  (|TrapModeExtraStack| . "TrapMode_ExtraStack")
	  (|TrapModeIO| . "TrapMode_IO")
	  (|TrapModeFEP| . "TrapMode_FEP")

	  (|HaltReasonIllInstn| . "HaltReason_IllInstn")
	  (|HaltReasonHalted| . "HaltReason_Halted")
	  (|HaltReasonSpyCalled| . "HaltReason_SpyCalled")
	  (|HaltReasonFatalStackOverflow| . "HaltReason_FatalStackOverflow")
	  (|HaltReasonIllegalTrapVector| . "HaltReason_IllegalTrapVector")

	  (|DoubleFloatOpAdd| . "DoubleFloatOp_Add")
	  (|DoubleFloatOpSub| . "DoubleFloatOp_Sub")
	  (|DoubleFloatOpMultiply| . "DoubleFloatOp_Multiply")
	  (|DoubleFloatOpDivide| . "DoubleFloatOp_Divide")

	  ))))

;
(defun isconstant (sym)
  (member sym
	  '(|TypeEvenPC|
	    |TrapVectorArithmeticInstructionException|
	    |TrapVectorStackOverflow|
	    |TrapVectorInstructionException|
	    |TrapVectorError|
	    |TrapVectorReset|
	    |TrapVectorPullApplyArgs|
	    |TrapVectorTrace|
	    |TrapVectorPreemptRequest|
	    |TrapVectorLowPrioritySequenceBreak|
	    |TrapVectorHighPrioritySequenceBreak|
	    |TrapVectorDBUnwindFrame|
	    |TrapVectorDBUnwindCatch|
	    |TrapVectorTransport|
	    |TrapVectorMonitor|
	    |TrapVectorPageNotResident|
	    |TrapVectorPageFaultRequest|
	    |TrapVectorPageWriteFault|
	    |TrapVectorUncorrectableMemoryError|
	    |TrapVectorMemoryBusError|
	    |ValueDispositionEffect|
	    |ValueDispositionValue|
	    |ValueDispositionReturn|
	    |ValueDispositionMultiple|
	    )))

;;  (cond
;;   ((eq sym '|TypeEvenPC|) t)
;;   (t nil)))

; return list of strings separated by char
(defun split-by-one-char (string char)
  (loop for i = 0 then (1+ j)
	as j = (position char string :start i)
	collect (subseq string i j)
	while j))

; return list of strings separated by "+"
(defun split-by-one-plus (string)
  (split-by-one-char string #\+))

; return list of strings separated by " "
(defun split-by-one-space (string)
  (split-by-one-char string #\Space))

; return list of strings separated by "*"
(defun split-by-one-star (string)
  (split-by-one-char string #\*))

(defun fixarg (str)
;  (format t "fixarg: str ~S~%" str)
  (let ((sym-name (if (symbolp str) (symbol-name str) nil)))
    (if (search "+" sym-name)
	;; handle case of xxx+4
	(let* ((split-list (split-by-one-plus sym-name))
	       (fixed-arg (fixarg (intern (car split-list))))
	       (last-part (car (cdr split-list))))
	  (setq str (concatenate 'string fixed-arg "+" last-part))
;;	  (format t "fixarg+: a=~S b=~S result ~S~%" fixed-arg last-part str)
	  )
      (if (search "*" sym-name)
	;; handle case of xxx*4
	  (let* ((split-list (split-by-one-star sym-name))
		 (fixed-arg (fixarg (intern (car split-list))))
		 (last-part (car (cdr split-list))))
	    (setq str (concatenate 'string fixed-arg "*" last-part))
;;	  (format t "fixarg+: a=~S b=~S result ~S~%" fixed-arg last-part str)
	    )
	;; normal case
	(let ((new (remap-arg str)))
	  (if new new
	    (if (numberp str) str
	      (string-downcase str))))))))

(defun regnum (arg)
 (subseq arg 1 2))

; return t if string is not a number
(defun notnumber (str)
  (let ((d0 (char-code #\0))
	(d9 (char-code #\9)))
    (some
     #'(lambda (c) (let ((cc (char-code c))) (or (< cc d0) (> cc d9))))
	 str)))

;; return (ptr member offset)
(defun decompose-args (arg1 arg2)
  (let ((arg2-name (if (symbolp arg2) (symbol-name arg2) arg2)))
    (if (not (search "+" arg2-name))
	(values (structptr arg1 arg2) arg2 0)
      ;; handle case of xxx+4
      (let* ((split-list (split-by-one-plus arg2-name))
	     (real-arg2 (intern (car split-list)))
	     (fixed-arg2 (fixarg real-arg2))
	     (offsetlast-part (car (cdr split-list)))
	     (ptr (structptr arg1 real-arg2))
	     (offset (if (notnumber offsetlast-part)
			 offsetlast-part (parse-integer offsetlast-part))))
	(values ptr fixed-arg2 offset)))))


; severe hackery
(defun is-cachep-member (smember)
  (member smember
	  '(cacheline_annotation cacheline_nextpdata cacheline_nextptag
				 cacheline_nextcp cacheline_instruction
				 cacheline_operand cacheline_pcdata
				 cacheline_pctag cacheline_code)))

(defun is-cachep-ptr (str)
  (or (eq str 'ocp) (eq str 'ecp) (eq str 'iCP) (equal str "iCP")))

(defun cacheline-ptr-str (ptr)
  (if (or (eq ptr 'iCP) (equal ptr "iCP"))
      "iCP"
    (string-downcase ptr)))

(defun needs-cacheline-cast (ptr member)
;  (format t "needs-cacheline-cast: ptr ~S member ~S~%" ptr member)
  (or
   (is-cachep-ptr ptr)
   (is-cachep-member member)))

(defun is-arrachcachep-member (amember)
  (member amember
	  '(arraycache_array
	    arraycache_arword arraycache_locat arraycache_length)))

(defun needs-arraycache-cast (ptr member)
   (is-arrachcachep-member member))

(defun is-processorstatep-member (pmember)
  (member pmember
	  '(
	    ;;--
	    PROCESSORSTATE_TRANSPARE3
	    PROCESSORSTATE_TRANSPARE2
	    PROCESSORSTATE_TRANSPARE1
	    PROCESSORSTATE_CARCDRSUBROUTINE
	    PROCESSORSTATE_CDRSUBROUTINE
	    PROCESSORSTATE_CARSUBROUTINE
	    PROCESSORSTATE_LINKAGE
	    PROCESSORSTATE_RESUMEEMA
	    PROCESSORSTATE_STATISTICS
	    PROCESSORSTATE_TRACE_HOOK
	    PROCESSORSTATE_INSTRUCTION_COUNT
	    PROCESSORSTATE_LONG_PAD0
	    PROCESSORSTATE_ASRR9
	    PROCESSORSTATE_ASRR10
	    PROCESSORSTATE_ASRR11
	    PROCESSORSTATE_ASRR12
	    PROCESSORSTATE_ASRR13
	    PROCESSORSTATE_ASRR14
	    PROCESSORSTATE_ASRR15
	    PROCESSORSTATE_LONG_PAD1
	    PROCESSORSTATE_ASRR26
	    PROCESSORSTATE_ASRR27
	    PROCESSORSTATE_ASRR29
	    PROCESSORSTATE_ASRR30
	    PROCESSORSTATE_ASRF2
	    PROCESSORSTATE_ASRF3
	    PROCESSORSTATE_ASRF4
	    PROCESSORSTATE_ASRF5
	    PROCESSORSTATE_ASRF6
	    PROCESSORSTATE_ASRF7
	    PROCESSORSTATE_ASRF8
	    PROCESSORSTATE_ASRF9
	    PROCESSORSTATE_METERDATABUFF
	    PROCESSORSTATE_METERPOS
	    PROCESSORSTATE_METERMAX
	    PROCESSORSTATE_METERFREQ
	    PROCESSORSTATE_METERMASK
	    PROCESSORSTATE_METERVALUE
	    PROCESSORSTATE_METERCOUNT
	    PROCESSORSTATE_CHOICEPTR
	    PROCESSORSTATE_SSTKCHOICEPTR
	    PROCESSORSTATE_DBCBASE
	    PROCESSORSTATE_DBCMASK
	    PROCESSORSTATE_COPROCESSORREADHOOK
	    PROCESSORSTATE_COPROCESSORWRITEHOOK
	    PROCESSORSTATE_FLUSHCACHES_HOOK
	    PROCESSORSTATE_I_STAGE_ERROR_HOOK
	    PROCESSORSTATE_SFP1
	    PROCESSORSTATE_FP0
	    PROCESSORSTATE_FP1
	    PROCESSORSTATE_FLOATING_EXCEPTION
	    PROCESSORSTATE_ALUANDROTATECONTROL
	    PROCESSORSTATE_ROTATELATCH
	    PROCESSORSTATE_ALUBORROW
	    PROCESSORSTATE_ALUOVERFLOW
	    PROCESSORSTATE_ALULESSTHAN
	    PROCESSORSTATE_ALUOP
	    PROCESSORSTATE_BYTEROTATE
	    PROCESSORSTATE_BYTESIZE
	    PROCESSORSTATE_BINDINGSTACKLIMIT
	    PROCESSORSTATE_BINDINGSTACKPOINTER
	    PROCESSORSTATE_CATCHBLOCK
	    PROCESSORSTATE_EXTRAANDCATCH
	    PROCESSORSTATE_MSCLOCKCACHE
	    PROCESSORSTATE_MSCMULTIPLIER
	    PROCESSORSTATE_PREVIOUSRCPP
	    PROCESSORSTATE_RLINK
	    PROCESSORSTATE_INTERRUPTREG
	    PROCESSORSTATE_ZONEOLDSPACE
	    PROCESSORSTATE_EPHEMERALOLDSPACE
	    PROCESSORSTATE_INT_PAD0
	    PROCESSORSTATE_EQNOTEQL
	    PROCESSORSTATE_LCLENGTH
	    PROCESSORSTATE_SCLENGTH
	    PROCESSORSTATE_LCAREA
	    PROCESSORSTATE_LCADDRESS
	    PROCESSORSTATE_SCAREA
	    PROCESSORSTATE_SCADDRESS
	    PROCESSORSTATE_RESTARTSP
	    PROCESSORSTATE_STOP_INTERPRETER
	    PROCESSORSTATE_IMMEDIATE_ARG
	    PROCESSORSTATE_CONTINUATIONCP
	    PROCESSORSTATE_CONTINUATION
	    PROCESSORSTATE_CONTROL
	    PROCESSORSTATE_NILADDRESS
	    PROCESSORSTATE_TADDRESS
	    PROCESSORSTATE_BAR0
	    PROCESSORSTATE_BAR1
	    PROCESSORSTATE_BAR2
	    PROCESSORSTATE_BAR3
	    PROCESSORSTATE_EPC
	    PROCESSORSTATE_FP
	    PROCESSORSTATE_LP
	    PROCESSORSTATE_SP
	    PROCESSORSTATE_CP
	    PROCESSORSTATE_FCCRMASK
	    PROCESSORSTATE_CSLIMIT
	    PROCESSORSTATE_CSEXTRALIMIT
	    PROCESSORSTATE_TRAPMETERDATA
	    PROCESSORSTATE_FEPMODETRAPVECADDRESS
	    PROCESSORSTATE_TRAPVECBASE
	    PROCESSORSTATE_TVI
	    PROCESSORSTATE_FCCRTRAPMASK
	    PROCESSORSTATE_PTRTYPE
	    PROCESSORSTATE_VMATTRIBUTETABLE
	    PROCESSORSTATE_VMA
	    PROCESSORSTATE_MOSTNEGATIVEFIXNUM
	    PROCESSORSTATE_ICACHEBASE
	    PROCESSORSTATE_ENDICACHE
	    PROCESSORSTATE_FULLWORDDISPATCH
	    PROCESSORSTATE_HALFWORDDISPATCH
	    PROCESSORSTATE_AREVENTCOUNT
	    PROCESSORSTATE_STACKCACHESIZE
	    PROCESSORSTATE_STACKCACHETOPVMA
	    PROCESSORSTATE_CDRCODEMASK
	    PROCESSORSTATE_STACKCACHEDATA
	    PROCESSORSTATE_STACKCACHEBASEVMA
	    PROCESSORSTATE_SCOVLIMIT
	    PROCESSORSTATE_SCOVDUMPCOUNT
	    PROCESSORSTATE_MOSTPOSITIVEFIXNUM
	    PROCESSORSTATE_INTERNALREGISTERREAD1
	    PROCESSORSTATE_INTERNALREGISTERREAD2
	    PROCESSORSTATE_INTERNALREGISTERWRITE1
	    PROCESSORSTATE_INTERNALREGISTERWRITE2
	    PROCESSORSTATE_DATAREAD_MASK
	    PROCESSORSTATE_DATAREAD
	    PROCESSORSTATE_DATAWRITE_MASK
	    PROCESSORSTATE_DATAWRITE
	    PROCESSORSTATE_BINDREAD_MASK
	    PROCESSORSTATE_BINDREAD
	    PROCESSORSTATE_BINDWRITE_MASK
	    PROCESSORSTATE_BINDWRITE
	    PROCESSORSTATE_BINDREADNOMONITOR_MASK
	    PROCESSORSTATE_BINDREADNOMONITOR
	    PROCESSORSTATE_BINDWRITENOMONITOR_MASK
	    PROCESSORSTATE_BINDWRITENOMONITOR
	    PROCESSORSTATE_HEADER_MASK
	    PROCESSORSTATE_HEADER
	    PROCESSORSTATE_STRUCTUREOFFSET_MASK
	    PROCESSORSTATE_STRUCTUREOFFSET
	    PROCESSORSTATE_SCAVENGE_MASK
	    PROCESSORSTATE_SCAVENGE
	    PROCESSORSTATE_CDR_MASK
	    PROCESSORSTATE_CDR
	    PROCESSORSTATE_GCCOPY_MASK
	    PROCESSORSTATE_GCCOPY
	    PROCESSORSTATE_RAW_MASK
	    PROCESSORSTATE_RAW
	    PROCESSORSTATE_RAWTRANSLATE_MASK
	    PROCESSORSTATE_RAWTRANSLATE
	    PROCESSORSTATE_PLEASE_STOP
	    PROCESSORSTATE_PLEASE_TRAP
	    PROCESSORSTATE_RUNNINGP
	    PROCESSORSTATE_AC0ARRAY
	    PROCESSORSTATE_AC0ARWORD
	    PROCESSORSTATE_AC0LOCAT
	    PROCESSORSTATE_AC0LENGTH
	    PROCESSORSTATE_AC1ARRAY
	    PROCESSORSTATE_AC1ARWORD
	    PROCESSORSTATE_AC1LOCAT
	    PROCESSORSTATE_AC1LENGTH
	    PROCESSORSTATE_AC2ARRAY
	    PROCESSORSTATE_AC2ARWORD
	    PROCESSORSTATE_AC2LOCAT
	    PROCESSORSTATE_AC2LENGTH
	    PROCESSORSTATE_AC3ARRAY
	    PROCESSORSTATE_AC3ARWORD
	    PROCESSORSTATE_AC3LOCAT
	    PROCESSORSTATE_AC3LENGTH
	    PROCESSORSTATE_AC4ARRAY
	    PROCESSORSTATE_AC4ARWORD
	    PROCESSORSTATE_AC4LOCAT
	    PROCESSORSTATE_AC4LENGTH
	    PROCESSORSTATE_AC5ARRAY
	    PROCESSORSTATE_AC5ARWORD
	    PROCESSORSTATE_AC5LOCAT
	    PROCESSORSTATE_AC5LENGTH
	    PROCESSORSTATE_AC6ARRAY
	    PROCESSORSTATE_AC6ARWORD
	    PROCESSORSTATE_AC6LOCAT
	    PROCESSORSTATE_AC6LENGTH
	    PROCESSORSTATE_AC7ARRAY
	    PROCESSORSTATE_AC7ARWORD
	    PROCESSORSTATE_AC7LOCAT
	    PROCESSORSTATE_AC7LENGTH
	    PROCESSORSTATE_TMCURRENTTRANSACTION
	    PROCESSORSTATE_TMWRITESTART
	    PROCESSORSTATE_TMWRITECURRENT
	    PROCESSORSTATE_TMWRITELIMIT
	    PROCESSORSTATE_TMRECORDINGREADS
	    PROCESSORSTATE_TMREADSTART
	    PROCESSORSTATE_TMREADCURRENT
	    PROCESSORSTATE_TMREADLIMIT
	    ;;--
	    )))

(defun needs-processorstate-cast (ptr member)
   (is-processorstatep-member member))

(defun check-needs-cast (ptr member)
  (cond
   ((needs-cacheline-cast ptr member)
    (format nil "((CACHELINEP)~A)" (cacheline-ptr-str ptr)))
   ((needs-arraycache-cast ptr member)
    (format nil "((ARRAYCACHEP)~A)" (string-downcase ptr)))
   ((eq ptr 'ivory) "processor")
   ((needs-processorstate-cast ptr member)
    (format nil "((PROCESSORSTATEP)~A)" (string-downcase ptr)))
   (t
    (if (stringp ptr) ptr (string-downcase ptr)))))

(defun structptr (str &optional member)
  (let ((new (remap-arg str)))
    (if new (check-needs-cast new member)
      (check-needs-cast str member))))

;;(defun gotolabel (str)
;;  (lc str))

(defun add-global-label-symbol (sym)
  (setq global-labels (append global-labels (list sym))))

(defun is-global-label (label)
  (if (equal label '|SetToCdrPushCarLocative|)
      t
    (if (equal label '|HALTMACHINE|)
	nil
      (member (if (stringp label) (intern label) label) global-labels))))

(defun gotolabel (str)
  (if (is-global-label str)
      str
    (lc str)))

; if number, return number+L, else return string
(defun longnum (str)
  (if (numberp str)
      (format nil "~AL" str)
    (string-downcase str)))

;
(setq call-label-count 0)

(defun make-call-label ()
    (setq call-label-count (+ 1 call-label-count))
    (format nil "return~4,'0D" call-label-count))

(setq just-start nil)
(setq global-labels nil)

;;;;
;; undo passthrus
(defun fix-passthrus nil
  (fmakunbound 'ldgp)
  (defmacro ldgp (&optional comment)
    `((ldgp $gp 0($27) ,@(if comment `(,comment)))))

  (fmakunbound 'divl)
  (defmacro divl (div by res &optional comment)
    `((divl ,div ,by ,res ,@(if comment `(,comment)))))

  (fmakunbound 'divq)
  (defmacro divq (div by res &optional comment)
    `((divq ,div ,by ,res ,@(if comment `(,comment)))))

  (fmakunbound 'divlu)
  (defmacro divlu (div by res &optional comment)
    `((divlu ,div ,by ,res ,@(if comment `(,comment)))))

  (fmakunbound 'divqu)
  (defmacro divqu (div by res &optional comment)
    `((m-divqu ,div ,by ,res ,@(if comment `(,comment)))))

  (fmakunbound 'reml)
  (defmacro reml (div by res &optional comment)
    `((reml ,div ,by ,res ,@(if comment `(,comment)))))

  (fmakunbound 'remlu)
  (defmacro remlu (div by res &optional comment)
    `((remlu ,div ,by ,res ,@(if comment `(,comment)))))

  (fmakunbound 'remlq)
  (defmacro remlq (div by res &optional comment)
    `((remlq ,div ,by ,res ,@(if comment `(,comment)))))

  (fmakunbound 'remqu)
  (defmacro remqu (div by res &optional comment)
    `((remqu ,div ,by ,res ,@(if comment `(,comment)))))
  )
;;;;

;;
(defun emit-operation (form destination)
;; (format t "emit-operation: form ~S~%" form)
;;  (format t "~S~%" form)
  (let ((cmd (car form))
	(arg1 (car (cdr form)))
	(arg2 (car (cddr form)))
	(arg3 (car (cdddr form)))
	(arg4 (car (cddddr form))))
;; (format t "cmd: ~S~%" cmd)
  (case cmd
	(start
	 (setq just-start t)
	 (format destination "/* start ~A */~%~%" arg1))
	(end
	 (format destination "~%/* end ~A */~%" arg1))
	(comment
	 (format destination "  /* ~A */~%" arg1))

	(label
;;	 (format t "label: ~S~%" arg1)
	 (let ((lname (if (is-global-label arg1) arg1 (gotolabel arg1))))
	   (format destination "~%~A:~%" lname)
	   (format destination "  if (_trace) printf(\"~A:\\n\");~%" lname)
	   (if (equal lname "continuecurrentinstruction")
	       (format destination "  if (_show) show_loc();~%" lname))))

	(func-label
	 (format destination "~%~A:~%" arg1))

	(unlikely-label
	 (format destination "~%~A:~%" (gotolabel arg1)))

	(cache-ivory-state
	 (format destination "  /* cache-ivory-state */~%")
	 (format destination "  iCP = processor->cp;~%")
	 (format destination "  iPC = processor->epc;~%")
	 (format destination "  iSP = processor->sp;~%")
	 (format destination "  iFP = processor->fp;~%")
	 (format destination "  iLP = processor->lp;~%"))

	(ADDL
	 (check-comment arg4)
	 (cond
	  ((equal arg1 'zero)
	   (format destination "  ~A = (s32)~A;~%"
		   (fixarg arg3) (fixarg arg2)))
	  ((equal arg2 'zero)
	   (format destination "  ~A = (s32)~A;~%"
		   (fixarg arg3) (fixarg arg1)))
	  (t
	   (format destination "  ~A = (s32)~A + (s32)~A;~%"
		   (fixarg arg3) (fixarg arg1) (fixarg arg2)))))

	(ADDL/V
	 (check-comment arg4)
	 (format destination
		 "//  ~A = (u64)((s32)~A + (s64)(s32)~A); /* addl/v */~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2))
	 (format destination
		 "  /* x86_64 replacement for addl/v */~%")
	 (format destination
		 "    asm(\"movl %k2,%k0 \\n\\t\"
	\"addl %k3,%k0 \\n\\t\"
	\"seto %b1\"
        : \"=r\"(~a),\"=rm\"(~a)
        : \"rm\"(~a),\"rm\"(~a)
        : \"cc\");~%"
	 (fixarg arg3)
	 "oflo"
	 (fixarg arg1)
	 (fixarg arg2))
	 (setq *do-check-oflo* t)
	 (format destination "//  if (~A >> 32)~%//    exception();~%"
		 (fixarg arg3)))

	(SUBL/V
	 (check-comment arg4)
	 (format destination
		 "//  ~A = (s64)((s32)~A - (s64)(s32)~A); /* subl/v */~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2))
	 (format destination
		 "  /* x86_64 replacement for subl/v */~%")
	 (format destination
		 "    asm(\"movl %k2,%k0 \\n\\t\"
	\"subl %k3,%k0 \\n\\t\"
	\"seto %b1\"
        : \"=r\"(~a),\"=rm\"(~a)
        : \"rm\"(~a),\"rm\"(~a)
        : \"cc\");~%"
	 (fixarg arg3)
	 "oflo"
	 (fixarg arg1)
	 (fixarg arg2))
	 (format destination "//  if (~A >> 32)~%//    exception();~%"
		 (fixarg arg3))
	 (setq *do-check-oflo* t))

	(ADDQ
	 (check-comment arg4)
	 (cond
	  ((eq arg1 'zero)
	   (format destination "  ~A = ~A;~%" (fixarg arg3) (fixarg arg2)))
	  ((eq arg2 'zero)
	   (format destination "  ~A = ~A;~%" (fixarg arg3) (fixarg arg1)))
	  (t
	   (format destination "  ~A = ~A + ~A;~%"
		   (fixarg arg3) (fixarg arg1) (fixarg arg2)))))

	('AND
	 (check-comment arg4)
	 (if (not (eq arg3 'zero))
	     (format destination "  ~A = ~A & ~A;~%"
		     (fixarg arg3) (fixarg arg1) (fixarg arg2))))

	(BIC
	 (check-comment arg4)
	 (format destination "  ~A = ~A & ~~~A;~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (longnum arg2)
		 ))

	(BIS
	 (check-comment arg4)
	 (cond
	  ((eq arg1 'zero)
	   (format destination "  ~A = ~A;~%" (fixarg arg3) (fixarg arg2)))
	  ((eq arg2 'zero)
	   (format destination "  ~A = ~A;~%" (fixarg arg3) (fixarg arg1)))
	  (t
	   (format destination "  ~A = ~A | ~A;~%"
		   (fixarg arg3) (fixarg arg1) (fixarg arg2)))))

	(BEQ
	 (check-comment arg3)
	 (format destination "  if (~A == 0)~%    goto ~A;~%"
		 (fixarg arg1) (gotolabel arg2)))

	(BLE
	 (check-comment arg3)
	 (format destination "  if ((s64)~A <= 0)~%    goto ~A;~%"
		 (fixarg arg1) (gotolabel arg2)))

	(BLT
	 (check-comment arg3)
	 (format destination "  if ((s64)~A < 0)~%    goto ~A;~%"
		 (fixarg arg1) (gotolabel arg2)))

	(BLBC
	 (check-comment arg3)
	 (format destination "  if ((~A & 1) == 0)~%    goto ~A;~%"
		 (fixarg arg1) (gotolabel arg2)))

	(BLBS
	 (check-comment arg3)
	 (format destination "  if (~A & 1)~%    goto ~A;~%"
		 (fixarg arg1) (gotolabel arg2)))

	(BGE
	 (check-comment arg3)
	 (format destination "  if ((s64)~A >= 0)~%    goto ~A;~%"
		 (fixarg arg1) (gotolabel arg2)))

	(BGT
	 (check-comment arg3)
	 (format destination "  if ((s64)~A > 0)~%    goto ~A;~%"
		 (fixarg arg1) (gotolabel arg2)))

	(BNE
	 (check-comment arg3)
	 (format destination "  if (~A != 0)~%    goto ~A;~%"
		 (fixarg arg1) (gotolabel arg2)))

	(BR
	 (check-comment arg4)
	 (format destination "  goto ~A;~%"
		 (gotolabel arg2)))

	(CLR
	 (check-comment arg2)
	 (format destination "  ~A = 0;~%"
		 (fixarg arg1)))

	(CMPBGE
	 (check-comment arg4)
	 (format destination "  ~A = CMPBGE(~A, ~A);~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2)))

	(CMPLE
	 (check-comment arg4)
	 (format destination "  ~A = ((s64)~A <= (s64)~A) ? 1 : 0;~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2)))

	(CMPEQ
	 (check-comment arg4)
	 (format destination "  ~A = (~A == ~A) ? 1 : 0;~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2)))

	(CMPLT
	 (check-comment arg4)
	 (format destination "  ~A = ((s64)~A < (s64)~A) ? 1 : 0;~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2)))

	(CMPTLE
	 (check-comment arg4)
	 (format destination
		 "  SETFLTT(~A,~A, FLTU64(~A,~A) <= FLTU64(~A,~A) ? 2.0:0);~%"
		 (regnum (fixarg arg3)) (fixarg arg3)
		 (regnum (fixarg arg1)) (fixarg arg1)
		 (regnum (fixarg arg2)) (fixarg arg2)))

	(CMPTLT
	 (check-comment arg4)
	 (format destination
		 "  SETFLTT(~A,~A, FLTU64(~A,~A) < FLTU64(~A,~A) ? 2.0:0);~%"
		 (regnum (fixarg arg3)) (fixarg arg3)
		 (regnum (fixarg arg1)) (fixarg arg1)
		 (regnum (fixarg arg2)) (fixarg arg2)))

	(CMPTEQ
	 (check-comment arg4)
	 (format destination
		 "  SETFLTT(~A,~A, FLTU64(~A,~A) == FLTU64(~A,~A) ? 2.0:0);~%"
		 (regnum (fixarg arg3)) (fixarg arg3)
		 (regnum (fixarg arg1)) (fixarg arg1)
		 (regnum (fixarg arg2)) (fixarg arg2)))

	(CMPULE
	 (check-comment arg4)
	 (format destination "  ~A = ((u64)~A <= (u64)~A) ? 1 : 0;~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2)))

	(CMPULT
	 (check-comment arg4)
	 (format destination "  ~A = ((u64)~A < (u64)~A) ? 1 : 0;~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2)))

	(CMOVLBS
	 (check-comment arg4)
	 (format destination "  if (~A & 1)~%"
		 (fixarg arg1))
	 (format destination "   ~A = ~A;~%"
		 (fixarg arg3)
		 (fixarg arg2)))

	(CMOVLBC
	 (check-comment arg4)
	 (format destination "  if ((~A & 1) == 0)~%"
		 (fixarg arg1))
	 (format destination "   ~A = ~A;~%"
		 (fixarg arg3)
		 (fixarg arg2)))

	(CMOVEQ
	 (check-comment arg4)
	 (format destination "  if (~A == 0)~%"
		 (fixarg arg1))
	 (format destination "    ~A = ~A;~%"
		 (fixarg arg3)
		 (fixarg arg2)))

	(CMOVGE
	 (check-comment arg4)
	 (format destination "  if ((s64)~A >= 0)~%"
		 (fixarg arg1))
	 (format destination "    ~A = ~A;~%"
		 (fixarg arg3)
		 (fixarg arg2)))

	(CMOVGT
	 (check-comment arg4)
	 (format destination "  if ((s64)~A > 0)~%"
		 (fixarg arg1))
	 (format destination "    ~A = ~A;~%"
		 (fixarg arg3)
		 (fixarg arg2)))

	(CMOVLE
	 (check-comment arg4)
	 (format destination "  if ((s64)~A <= 0)~%"
		 (fixarg arg1))
	 (format destination "    ~A = ~A;~%"
		 (fixarg arg3)
		 (fixarg arg2)))

	(CMOVLT
	 (check-comment arg4)
	 (format destination "  if ((s64)~A < 0)~%"
		 (fixarg arg1))
	 (format destination "    ~A = ~A;~%"
		 (fixarg arg3)
		 (fixarg arg2)))

	(CMOVNE
	 (check-comment arg4)
	 (format destination "  if (~A)~%"
		 (fixarg arg1))
	 (format destination "    ~A = ~A;~%"
		 (fixarg arg3)
		 (fixarg arg2)))

	(CPYSN
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (format destination "  CPYSN(~A, ~A, ~A, ~A, ~A, ~A);~%"
		 (regnum (fixarg arg3)) (fixarg arg3)
		 (regnum (fixarg arg1)) (fixarg arg1)
		 (regnum (fixarg arg2)) (fixarg arg2)))

	(CVTQL
	   (format destination "  CVTQL(~A, ~A, ~A, ~A, ~A);~%"
		   (regnum (fixarg arg3)) (fixarg arg3)
		   (fixarg arg1)
		   (regnum (fixarg arg2)) (fixarg arg2)))

	(CVTQL/V
	   (format destination "  CVTQLV(~A, ~A, ~A, ~A, ~A);~%"
		   (regnum (fixarg arg3)) (fixarg arg3)
		   (fixarg arg1) (regnum (fixarg arg2)) (fixarg arg2)))

	(CVTQS
	   (format destination "  CVTQS(~A, ~A, ~A, ~A, ~A);~%"
		   (regnum (fixarg arg3)) (fixarg arg3)
		   (fixarg arg1) (regnum (fixarg arg2)) (fixarg arg2)))

	(CVTQT
	   (format destination "  CVTQT(~A, ~A, ~A, ~A, ~A);~%"
		   (regnum (fixarg arg3)) (fixarg arg3)
		   (fixarg arg1) (regnum (fixarg arg2)) (fixarg arg2)))

	(CVTLQ
	   (format destination "  CVTLQ(~A, ~A, ~A, ~A, ~A);~%"
		   (regnum (fixarg arg3)) (fixarg arg3)
		   (fixarg arg1) (regnum (fixarg arg2)) (fixarg arg2)))

	(CVTTQ
	   (format destination "  CVTTQ(~A, ~A, ~A, ~A, ~A);~%"
		   (regnum (fixarg arg3)) (fixarg arg3)
		   (fixarg arg1) (regnum (fixarg arg2)) (fixarg arg2)))

	(CVTTQ/V
	   (format destination "  CVTTQV(~A, ~A, ~A, ~A, ~A);~%"
		   (regnum (fixarg arg3)) (fixarg arg3)
		   (fixarg arg1) (regnum (fixarg arg2)) (fixarg arg2)))

	(CVTTQ/VC
	   (format destination "  CVTTQVC(~A, ~A, ~A, ~A, ~A);~%"
		   (regnum (fixarg arg3)) (fixarg arg3)
		   (fixarg arg1) (regnum (fixarg arg2)) (fixarg arg2)))

	(CVTTQ/VM
	   (format destination "  CVTTQVM(~A, ~A, ~A, ~A, ~A);~%"
		   (regnum (fixarg arg3)) (fixarg arg3)
		   (fixarg arg1) (regnum (fixarg arg2)) (fixarg arg2)))

	(CVTTQ/SVI
	   (format destination "  CVTTQSVI(~A, ~A, ~A, ~A, ~A);~%"
		   (regnum (fixarg arg3)) (fixarg arg3)
		   (fixarg arg1) (regnum (fixarg arg2)) (fixarg arg2)))

	(CVTTS
	   (format destination "  CVTTS(~A, ~A, ~A, ~A, ~A);~%"
		   (regnum (fixarg arg3)) (fixarg arg3)
		   (fixarg arg1) (regnum (fixarg arg2)) (fixarg arg2)))

	(M-DIVQU
	 (check-comment arg4)
	 (format destination "  ~A = ~A / ~A;~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2)))

	(EXTERNAL-BRANCH
	 (format destination "  goto ~A;~%"
		 (gotolabel arg1)))

	(EXTBL
	 (check-comment arg4)
	 (if (eq arg2 0)
	     (format destination "  ~A = (u8)~A;~%"
		     (fixarg arg3) (fixarg arg1))
	   (format destination "  ~A = (u8)(~A >> ((~A&7)*8));~%"
		   (fixarg arg3) (fixarg arg1) (fixarg arg2))))

	(EXTWL
	 (check-comment arg4)
	 (if (eq arg2 0)
	     (format destination "  ~A = (u16)~A;~%"
		     (fixarg arg3) (fixarg arg1))
	   (format destination "  ~A = (u16)(~A >> ((~A&7)*8));~%"
		   (fixarg arg3) (fixarg arg1) (fixarg arg2))))

	(EXTLL
	 (check-comment arg4)
	 (if (eq arg2 0)
	     (format destination "  ~A = (u32)~A;~%"
		     (fixarg arg3) (fixarg arg1))
	   (format destination "  ~A = (u32)(~A >> ((~A&7)*8));~%"
		   (fixarg arg3) (fixarg arg1) (fixarg arg2))))

	(FBEQ
	 (check-comment arg3)
	 (format destination "  if (FLTU64(~A, ~A) == 0.0)~%    goto ~A;~%"
		 (regnum (fixarg arg1)) (fixarg arg1)
		 (gotolabel arg2)))

	(FBLT
	 (check-comment arg3)
	 (format destination "  if (FLTU64(~A, ~A) < 0.0)~%    goto ~A;~%"
		 (regnum (fixarg arg1)) (fixarg arg1)
		 (gotolabel arg2)))

	(FBGT
	 (check-comment arg3)
	 (format destination "  if (FLTU64(~A, ~A) > 0.0)~%    goto ~A;~%"
		 (regnum (fixarg arg1)) (fixarg arg1)
		 (gotolabel arg2)))

	(FBNE
	 (check-comment arg3)
	 (format destination "  if (FLTU64(~A, ~A) != 0.0)~%    goto ~A;~%"
		 (regnum (fixarg arg1)) (fixarg arg1)
		 (gotolabel arg2)))

	(FCMOVGT
	 (check-comment arg4)
	 (format destination "  if (FLTU64(~A, ~A) > 0.0)~%"
		 (regnum (fixarg arg1)) (fixarg arg1))
	 (format destination "    ~A = ~A;~%"
		 (fixarg arg3) (fixarg arg2)))

	(FCMOVLT
	 (check-comment arg4)
	 (format destination "  if (FLTU64(~A, ~A) < 0.0)~%"
		 (regnum (fixarg arg1)) (fixarg arg1))
	 (format destination "    ~A = ~A;~%"
		 (fixarg arg3) (fixarg arg2)))

	(INSBL
	 (check-comment arg4)
	 (format destination "  ~A = (~A & 0xff) << ((~A&7)*8);~%"
		 (fixarg arg3) (fixarg arg1) (fixarg arg2)))

	(JMP
	 (check-comment arg4)
	 (format destination "    goto *((void *) ~A); /* jmp */~%"
		 (fixarg arg2)))

	(JSR
	 (check-comment arg4)
	 (format destination
		 "    r0 = (*( u64 (*)(u64, u64) )~A)(arg1, arg2); /* jsr */~%"
		 (fixarg arg2)))

	(FETCH)
	(FETCH_M)

	(LDA
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (cond
	  ((eq arg2 0)
	   (format destination "  ~A = ~A;~%"
		   (fixarg arg1) (fixarg arg3)))
	  ((or (numberp arg2) (isconstant arg2) (eq arg3 'zero))
	   (format destination "  ~A = ~A + ~A;~%"
		   (fixarg arg1) (fixarg arg3) (fixarg arg2)))
	  (t
	   (format destination "  ~A = (u64)&~A->~A;~%"
		   (fixarg arg1) (structptr arg3 arg2) (fixarg arg2)))))

	(LDAH
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (if (or (eq arg3 0) (eq arg3 'zero))
	     (format destination "  ~A = (~A) << 16;~%"
		     (fixarg arg1) (fixarg arg2))
	   (if (or (numberp arg2) (isconstant arg2))
	       (format destination "  ~A = ~A + ((~A) << 16);~%"
		       (fixarg arg1) (fixarg arg3) (fixarg arg2))
	     (format destination "  ~A = (u64)&~A->~A;~%"
		     (fixarg arg1) (structptr arg3 arg2) (fixarg arg2)))))

	(LDL
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (if (numberp arg2)
	     (if (eq arg2 0)
		 (format destination "  ~A = *(s32 *)~A;~%"
			 (fixarg arg1) (fixarg arg3))
	       (format destination "  ~A = *(s32 *)(~A + ~A);~%"
		       (fixarg arg1) (fixarg arg3) (fixarg arg2)))
	   ;; handle ugly x+4 case
	   (multiple-value-bind (ptr member offset)
				(decompose-args arg3 arg2)
		(if (numberp offset)
		    (progn
		      (if (eq (mod offset 4) 0)
			  (setq offset (/ offset 4))
			(format t "*** LDL, offset not mult 4; ~S" form)))
		  (setq offset (format nil "~A/4" offset)))
		(cond
		 ((eq offset 0)
		    (format destination "  ~A = *(s32 *)&~A->~A;~%"
			    (fixarg arg1) ptr (fixarg member)))
		 (t
		  (format destination "  ~A = *((s32 *)(&~A->~A)+~A);~%"
			  (fixarg arg1) ptr (fixarg member) offset))))))

	(LDQ
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (if (or (numberp arg2) (isconstant arg2))
	     (if (eq arg2 0)
		 (format destination "  ~A = *(u64 *)~A;~%"
			 (fixarg arg1) (fixarg arg3))
	       (format destination "  ~A = *(u64 *)(~A + ~A);~%"
		       (fixarg arg1) (fixarg arg3) (fixarg arg2)))
	   ;; member not number or constant
	   (let ((ptr (structptr arg3 arg2)))
	     ;; hack
	     (if (or
		  (equal ptr "((PROCESSORSTATEP)t8)")
		  (equal ptr "((PROCESSORSTATEP)t12)"))
		 (let ((asmoffset
			(cond
			 ((eq arg2 'PROCESSORSTATE_DATAREAD_MASK)
			  "PROCESSORSTATE_DATAREAD_MASK")
			 ((eq arg2 'PROCESSORSTATE_DATAREAD)
			  "PROCESSORSTATE_DATAREAD"))))
		   (format destination "  ~A = *(u64 *)(~A + ~A);~%"
			   (fixarg arg1) (fixarg arg3) asmoffset))
	       ;; normal case
	       (format destination "  ~A = *(u64 *)&(~A->~A);~%"
		       (fixarg arg1) ptr (fixarg arg2))))))

	(LDQ_U
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (if (eq arg2 0)
	     (format destination "  ~A = LDQ_U(~A);~%"
		     (fixarg arg1) (fixarg arg3))
	   (format destination "  ~A = LDQ_U(&~A->~A);~%"
		   (fixarg arg1) (structptr arg3) (fixarg arg2))))

	(LDQ_L
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (if (eq arg2 0)
	     (format destination "  ~A = *(u64 *)~A; /* lock */~%"
		     (fixarg arg1) (fixarg arg3))
	   (format destination "  ~A = *(u64 *)&(~A->~A); /* lock */~%"
		   (fixarg arg1) (structptr arg3) (fixarg arg2))))

	(LDS
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (if (eq arg2 0)
	     (format destination "  LDS(~A, ~A, *(u32 *)~A );~%"
		     (regnum (fixarg arg1)) (fixarg arg1) (fixarg arg3))
	   (format destination "  LDS(~A, ~A, ~A->~A);~%"
		   (regnum (fixarg arg1))
		   (fixarg arg1) (structptr arg3) (fixarg arg2))))

	(LDT
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (if (eq arg2 0)
	     (format destination "  LDT(~A, ~A, *(u32 *)~A );~%"
		     (regnum (fixarg arg1)) (fixarg arg1) (fixarg arg3))
	   (format destination "  LDT(~A, ~A, ~A->~A);~%"
		   (regnum (fixarg arg1))
		   (fixarg arg1) (structptr arg3) (fixarg arg2))))

	(STS
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (if (numberp arg2)
	     (if (eq arg2 0)
		 (format destination "  STS( (u32 *)~A, ~A, ~A );~%"
			 (structptr arg3) (regnum (fixarg arg1)) (fixarg arg1))
	       (format destination "  STS( (u32 *)(~A + ~A), ~A, ~A );~%"
		       (structptr arg3 arg2) (fixarg arg2)
		       (regnum (fixarg arg1)) (fixarg arg1)))
	   (format destination "  STS( (u32 *)&~A->~A, ~A, ~A );~%"
		   (structptr arg3) (fixarg arg2)
		   (regnum (fixarg arg1)) (fixarg arg1))))

	(STT
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (if (numberp arg2)
	     (if (eq arg2 0)
		 (format destination "  STT( (u64 *)~A, ~A, ~A );~%"
			 (structptr arg3) (regnum (fixarg arg1)) (fixarg arg1))
	       (format destination "  STT( (u64 *)(~A + ~A), ~A, ~A );~%"
		       (structptr arg3 arg2) (fixarg arg2)
		       (regnum (fixarg arg1)) (fixarg arg1)))
	   (format destination "  STT( (u64 *)&~A->~A, ~A, ~A );~%"
		   (structptr arg3) (fixarg arg2)
		   (regnum (fixarg arg1)) (fixarg arg1))))

	(ADDS
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (format destination "  ADDS(~A, ~A, ~A, ~A, ~A, ~A); /* adds */~%"
		 (regnum (fixarg arg3)) (fixarg arg3)
		 (regnum (fixarg arg1)) (fixarg arg1)
		 (regnum (fixarg arg2)) (fixarg arg2)))

	(ADDT
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (format destination "  ADDT(~A, ~A, ~A, ~A, ~A, ~A); /* addt */~%"
		 (regnum (fixarg arg3)) (fixarg arg3)
		 (regnum (fixarg arg1)) (fixarg arg1)
		 (regnum (fixarg arg2)) (fixarg arg2)))

	(SUBS
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (if (not (equal arg3 'zero))
	     (format destination "  SUBS(~A, ~A, ~A, ~A, ~A, ~A); /* subs */~%"
		 (regnum (fixarg arg3)) (fixarg arg3)
		     (regnum (fixarg arg1)) (fixarg arg1)
		     (regnum (fixarg arg2)) (fixarg arg2))))

	(SUBT
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (format destination "  SUBT(~A, ~A, ~A, ~A, ~A, ~A);~%"
		 (regnum (fixarg arg3)) (fixarg arg3)
		 (regnum (fixarg arg1)) (fixarg arg1)
		 (regnum (fixarg arg2)) (fixarg arg2)))

	(MULS
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (format destination "  MULS(~A, ~A, ~A, ~A, ~A, ~A); /* muls */~%"
		 (regnum (fixarg arg3)) (fixarg arg3)
		 (regnum (fixarg arg1)) (fixarg arg1)
		 (regnum (fixarg arg2)) (fixarg arg2)))

	(MULT
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (format destination "  MULT(~A, ~A, ~A, ~A, ~A, ~A);~%"
		 (regnum (fixarg arg3)) (fixarg arg3)
		 (regnum (fixarg arg1)) (fixarg arg1)
		 (regnum (fixarg arg2)) (fixarg arg2)))

	(DIVS
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (format destination "  DIVS(~A, ~A, ~A, ~A, ~A, ~A); /* divs */~%"
		 (regnum (fixarg arg3)) (fixarg arg3)
		 (regnum (fixarg arg1)) (fixarg arg1)
		 (regnum (fixarg arg2)) (fixarg arg2)))

	(DIVT
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (format destination "  DIVT(~A, ~A, ~A, ~A, ~A, ~A);~%"
		 (regnum (fixarg arg3)) (fixarg arg3)
		 (regnum (fixarg arg1)) (fixarg arg1)
		 (regnum (fixarg arg2)) (fixarg arg2)))

	(LOAD-CONSTANT
	 (check-comment arg4)
	 (if (numberp arg2)
	     (format destination "  ~A = 0x~X;~%"
		     (fixarg arg1)
		     arg2)
	   (format destination "  ~A = ~A;~%"
		   (fixarg arg1)
		   (fixarg arg2))))

	(MSKBL
	 (check-comment arg4)
	 (format destination "  ~A = ~A & ~~(0xffL << (~A&7)*8);~%"
		 (fixarg arg3) (fixarg arg1) (fixarg arg2)))

	(MULQ
	 (check-comment arg4)
	 (format destination "  ~A = ~A * ~A;~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2)))

	(MULL/V
	 (check-comment arg4)
	 (format destination
		 "//  ~A = (s64)((s32)~A * (s64)(s32)~A); /* mull/v */~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2))
	 (format destination
		 "  /* x86_64 replacement for mull/v */~%")
	 (format destination
		 "    asm(\"movl %k2,%k0 \\n\\t\"
	\"imull %k3,%k0 \\n\\t\"
	\"seto %b1\"
        : \"=r\"(~a),\"=rm\"(~a)
        : \"rm\"(~a),\"rm\"(~a)
        : \"cc\");~%"
	 (fixarg arg3)
	 "oflo"
	 (fixarg arg1)
	 (fixarg arg2))
	 (setq *do-check-oflo* t)
	 (format destination "//  if (~A >> 32)~%//    exception();~%"
		 (fixarg arg3)))

	(X64RATQUO
	 (check-comment arg4)
	 (format destination
		 "  /* x86_64 replacement for fixnum rational quotient */~%")
	 (format destination
		 "    asm(\"movl %k2,%%eax \\n\\t\"~36,4T// get arg1 into res
        \"cdq \\n\\t\"~36,4T// sign extend into edx:eax
        \"idivl %k3 \\n\\t\"~36,4T// divide by arg2
        \"movl %%eax,%k0 \\n\\t\"~36,4T// result into f0
        \"movl %%edx,%k1\"~36,4T// remainder into im1
        : \"=mr\"(~a),\"=rm\"(~a)~36,4T// %0;res, %1:im1
        : \"rm\"(~a),\"rm\"(~a)~36,4T// %2:t2, %3:t4
        : \"rax\", \"rdx\", \"cc\");~36,4T// clobbers eax, edx and cc;~%"
	 (fixarg arg1)
	 "im1"
	 (fixarg arg2)
	 (fixarg arg3))
	 (setq *do-check-ratquo* t))

	(LIBMFLOOR
	 (format destination
		 "  /* use libc function floor for rounding-mode :down */~%")
	 (format destination
		 "  {~%    extern double floor(double);~%")
	 (format destination
		 "    double c = floor( FLTU64(1, ~a) / FLTU64(2, ~a) );~%"
		 (fixarg arg1)
		 (fixarg arg2))
	 (format destination
		 "    double d = FLTU64(1, ~a) - (c * FLTU64(2, ~a)) ;~%"
		 (fixarg arg1)
		 (fixarg arg2))
	 (format destination
		 "    LDS(0, ~a, (int)c);~%"
		 (fixarg arg4))
	 (format destination
		 "    LDT(3, ~a, U64FLTT(d));~%  }~%"
		 (fixarg arg3)))

	(LIBMCEIL
;;	 (check-comment arg4)
	 (format destination
		 "  /* use libc function ceil for rounding-mode :up */~%")
	 (format destination
		 "  {~%    extern double ceil(double);~%")
	 (format destination
		 "    double c = ceil( FLTU64(1, ~a) / FLTU64(2, ~a) );~%"
		 (fixarg arg1)
		 (fixarg arg2))
	 (format destination
		 "    double d = FLTU64(1, ~a) - (c * FLTU64(2, ~a)) ;~%"
		 (fixarg arg1)
		 (fixarg arg2))
	 (format destination
		 "    LDS(0, ~a, (int)c);~%"
		 (fixarg arg4))
	 (format destination
		 "    LDT(3, ~a, U64FLTT(d));~%  }~%"
		 (fixarg arg3)))

	(LIBMTRUNC
;;	 (check-comment arg4)
	 (format destination
		 "  /* use libc function trunc for rounding-mode :truncate */~%")
	 (format destination
		 "  {~%    extern double trunc(double);~%")
	 (format destination
		 "    double c = trunc( FLTU64(1, ~a) / FLTU64(2, ~a) );~%"
		 (fixarg arg1)
		 (fixarg arg2))
	 (format destination
		 "    double d = FLTU64(1, ~a) - (c * FLTU64(2, ~a)) ;~%"
		 (fixarg arg1)
		 (fixarg arg2))
	 (format destination
		 "    LDS(0, ~a, (int)c);~%"
		 (fixarg arg4))
	 (format destination
		 "    LDT(3, ~a, U64FLTT(d));~%  }~%"
		 (fixarg arg3)))

	(LIBMRINT
;;	 (check-comment arg4)
	 (format destination
		 "  /* use libc function rint for rounding-mode :round */~%")
	 (format destination
		 "  {~%    extern double rint(double);~%")
	 (format destination
		 "    double c = rint( FLTU64(1, ~a) / FLTU64(2, ~a) );~%"
		 (fixarg arg1)
		 (fixarg arg2))
	 (format destination
		 "    double d = FLTU64(1, ~a) - (c * FLTU64(2, ~a)) ;~%"
		 (fixarg arg1)
		 (fixarg arg2))
	 (format destination
		 "    LDS(0, ~a, (int)c);~%"
		 (fixarg arg4))
	 (format destination
		 "    LDT(3, ~a, U64FLTT(d));~%  }~%"
		 (fixarg arg3)))

	;; (X64DFLTEXC
	;;  (check-comment arg4)
	;;  (format destination
	;; 	 "  if (((~a >> 10) & 0xff) == Opcode_DoubleFloatOp) goto ~a;~%"
	;; 	 (fixarg arg1)
	;; 	 (fixarg arg2)))

	(X64EXECTIMES
	 (format destination
		 "#ifdef EXECTIMES~%")
	 (format destination
		 "  getrusage(RUSAGE_SELF,&_rusage);~%")
	 (format destination
		 "  if (_lastcode != 0xFFFF) {~%")
	 (format destination
		 "    _exectimes[_lastcode] += (_rusage.ru_utime.tv_usec +~%")
	 (format destination
		 "                             _rusage.ru_utime.tv_sec * 1000000) - _lastinststart;~%  }~%")
	 (format destination
		 "  _lastcode = ~a ;~%"
		 (fixarg arg1))
	 (format destination
		 "  _lastinststart = (_rusage.ru_utime.tv_usec +~%")
	 (format destination
		 "                   _rusage.ru_utime.tv_sec * 1000000);~%")
	 (format destination
		 "#endif // EXECTIMES~%"))

	(NOP)

	(ORNOT
	 (check-comment arg4)
	 (if (eq arg1 'zero)
	     (format destination "  ~A = ~~~A;~%"
		     (fixarg arg3) (fixarg arg2))
	   (format destination "  ~A = ~A | ~~(~A);~%"
		   (fixarg arg3) (fixarg arg1) (fixarg arg2))))

	(RPCC
	   (format destination "  ~A = RPCC();~%"
		   (fixarg arg1)))

	(SRA
	 (check-comment arg4)
	 (setq shiftarg
	       (if (numberp arg2) (logand arg2 63)
		 (format nil "(~A & 63)" (fixarg arg2))))
	 (format destination "  ~A = (s64)~A >> ~A;~%"
		 (fixarg arg3) (fixarg arg1) shiftarg))

	(SRL
	 (check-comment arg4)
	 (setq shiftarg
	       (if (numberp arg2) (logand arg2 63)
		 (format nil "(~A & 63)" (fixarg arg2))))
	 (format destination "  ~A = ~A >> ~A;~%"
		 (fixarg arg3) (fixarg arg1) shiftarg))

	(SLL
	 (check-comment arg4)
	 (setq shiftarg
	       (if (numberp arg2) (logand arg2 63)
		 (format nil "(~A & 63)" (fixarg arg2))))
	 (format destination "  ~A = ~A << ~A;~%"
		 (fixarg arg3) (fixarg arg1) shiftarg))

	(SUBQ
	 (check-comment arg4)
	 (if (not (equal arg3 'zero))
	     (format destination "  ~A = ~A - ~A;~%"
		     (fixarg arg3) (fixarg arg1) (fixarg arg2))))

	(SUBL
	 (check-comment arg4)
	 (if (not (equal arg3 'zero))
	     (format destination "  ~A = (s32)~A - (s32)~A;~%"
		     (fixarg arg3) (fixarg arg1) (fixarg arg2))))

	(S4ADDQ
	 (check-comment arg4)
	 (if (equal arg2 'zero)
	     (format destination "  ~A = (~A * 4);~%"
		     (fixarg arg3) (fixarg arg1))
	   (format destination "  ~A = (~A * 4) + ~A;~%"
		   (fixarg arg3) (fixarg arg1) (fixarg arg2))))

	(S8ADDQ
	 (check-comment arg4)
	 (format destination "  ~A = (~A * 8) + ~A;~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2)))

	(S4SUBQ
	 (check-comment arg4)
	 (format destination "  ~A = (~A * 4) - ~A;~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2)))

	(S8SUBQ
	 (check-comment arg4)
	 (format destination "  ~A = (~A * 8) - ~A;~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2)))

	(STL
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (if (numberp arg2)
	     (if (eq arg2 0)
		 (format destination "  *(u32 *)~A = ~A;~%"
			 (fixarg arg3) (fixarg arg1))
	       (format destination "  *(u32 *)(~A + ~A) = ~A;~%"
		       (fixarg arg3) (fixarg arg2) (fixarg arg1)))
	   ;; handle ugly x+4 case
	   (multiple-value-bind (ptr member offset)
				(decompose-args arg3 arg2)
		(if (numberp offset)
		    (progn
		      (if (eq (mod offset 4) 0)
			  (setq offset (/ offset 4))
			(format t "*** STL, offset not mult 4; ~S" form)))
		  (setq offset (format nil "~A/4" offset)))
		(cond
		 ((eq offset 0)
		  (format destination "  *(u32 *)&~A->~A = ~A;~%"
			  ptr (fixarg member) (fixarg arg1)))
		 (t
		  (format destination "  *((u32 *)(&~A->~A)+~A) = ~A;~%"
			  ptr (fixarg member) offset (fixarg arg1)))))))

	(STQ
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (if (numberp arg2)
	     (if (eq arg2 0)
		 (format destination "  *(u64 *)~A = ~A;~%"
			 (structptr arg3 arg2) (fixarg arg1))
	       (format destination "  *(u64 *)(~A + ~A) = ~A;~%"
		       (structptr arg3 arg2) (fixarg arg2) (fixarg arg1)))
	   ;; handle ugly x+4 case
	   (multiple-value-bind (ptr member offset)
				(decompose-args arg3 arg2)
		(if (numberp offset)
		    (progn
		      (if (eq (mod offset 8) 0)
			  (setq offset (/ offset 8))
			(format t "*** STQ, offset not mult 8; ~S" form)))
		  (setq offset (format nil "~A/8" offset)))
		(cond
		 ((eq offset 0)
		  ;; hack! two even!
		  (if (equal ptr "((PROCESSORSTATEP)arg1)")
		      (setq ptr "processor"))
		  ;;
		  (format destination "  *(u64 *)&~A->~A = ~A;~%"
			  ptr (fixarg member) (fixarg arg1)))
		 (t
		  (format destination "  *((u64 *)(&~A->~A)+~A) = ~A;~%"
			  ptr (fixarg member) offset (fixarg arg1)))))))

	(STQ_C
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (format destination "  *(u64 *)&~A->~A = ~A; /* lock */~%"
		 (structptr arg3) (fixarg arg2) (fixarg arg1))
	 (format destination "  ~A = 1;~%"
		 (fixarg arg1)))

	(STQ_U
	 (check-comment arg4)
	 (if (listp arg3)
	     (setq arg3 (car arg3)))
	 (if (eq arg2 0)
	     (format destination "  STQ_U(~A, ~A);~%"
		     (fixarg arg3)
		     (fixarg arg1))
	   (format destination "  STQ_U((u64)&~A->~A, ~A);~%"
		   (structptr arg3)
		   (fixarg arg2)
		   (fixarg arg1))))

	(TRAPB
	 (check-comment arg1)
	 (format destination "  /* trapb ~A */~%"
		 (fixarg arg1))
	 (when *do-check-oflo*
	   (format destination "  CHECK_OFLO(); /* check overflow */~%")
	   (setq *do-check-oflo* nil))
	 (when *do-check-ratquo*
	   (format destination "  if (im1)~%    goto arithmeticexception;~%")
	   (setq *do-check-ratquo* nil)))

	(XOR
	 (check-comment arg4)
	 (format destination "  ~A = ~A ^ ~A;~%"
		 (fixarg arg3)
		 (fixarg arg1)
		 (fixarg arg2)))

	;-------------------------------------

	(CALL-SUBROUTINE
	 (setq label (make-call-label))
	 (format destination "  ~A = (u64)&&~A;~%" (fixarg arg1) label)
	 (format destination "  goto ~A;~%" (gotolabel arg2))
	 (format destination "~A:~%" label))

	(RET
	 (if (eq arg1 'zero)
	     (format destination "  goto *((void *) ~A); /* ret */~%" (fixarg arg2))
	   (format t "*** RET w/arg1")))

	(TAGTYPE
	 (check-comment arg3)
	 (format destination "  ~A = ~A & 0x3f;~%"
		 (fixarg arg2)
		 (fixarg arg1)))

	(VM-READ
	 (setq arg5 (car (cdr (cddddr form))))
	 (format destination "  /* vm-read */~%")
	 (format destination "  ~A = (char *)ivory + ~A;~%"
		 (fixarg arg5) (fixarg arg1))
	 (format destination "  ~A = ~A << 2;~%"
		 (fixarg arg3) (fixarg arg5))
	 (format destination "  ~A = *(unsigned char *)~A;~%"
		 (fixarg arg2) (fixarg arg5))
	 (format destination "  ~A = *(u32 *)~A;~%"
		 (fixarg arg2) (fixarg arg2)))

	(PASSTHRU
	 (if (search ".globl" arg1)
	     (let ((split-list (split-by-one-space arg1)))
	       (add-global-label-symbol (intern (car (cdr split-list))))))
;;	 (format t "~S~%" global-labels)
;;	 (format t "passthru: arg1 ~S form ~S~%" arg1 form)
	 (if (or (equal (ext:substring arg1 0 5) "#ifde")
		 (equal (ext:substring arg1 0 5) "#ifnd")
		 (equal (ext:substring arg1 0 4) "#end"))
	     (format destination "~A~%" arg1)))

	(otherwise
	 (format t "***UNKNOWN FORM: ~S~%" form))

	))
  1
  )

;;; PROCESS-ASM-FORM handles the expansion of assembler macros.  An
;;; assembler macro expands into a list of assembler operations any one of
;;; these may also be a macro The result of this loop is the linearization
;;; of assembler macros.
(defun process-asm-form (form destination &optional env)
; (format t "process-asm-form: form ~S~%" form)
  (if (consp (first form))
      (loop for meform in form
	    summing (process-asm-form meform destination env))
      (let ((expanded (macroexpand-careful form env)))
	(if (eq expanded form)
	    (emit-operation form destination)
	    (loop for meform in expanded
		  summing (process-asm-form meform destination env))))))


(defun process-asm-source (sourcefilename targetname)
  (with-open-file (sfs sourcefilename :direction :input)
    (with-open-file (tfs targetname :direction :output
				    :if-exists :supersede)
      (let ()
	(c-header tfs sourcefilename)
	(do ((form (read sfs nil :eof) (read sfs nil :eof)))
	    ((eq form :eof) nil)
	  (when (consp form)
	    (process-asm-form form tfs)))
	(c-trailer tfs sourcefilename)))))

(defun create-output-files ()
;  (setq count 0)
;  (format t "~%")
  (dolist (file '("ifunhead" "idispat" "ifuncom1" "ifuncom2"
 		  "ifungene" "ifunfcal" "ifunloop" "ifunlist"
 		  "ifuninst" "ifunmath" "ifunarra" "ifunmove"
 		  "ifunpred" "ifunsubp" "ifunfext" "ifunlexi"
 		  "ifunbits" "ifunblok" "ifunbind" "ifunfull"
 		  "ifunbnum" "ifuntrap" "ihalt" "idouble"
 		  "ifunjosh" "ifuntran"))
    (progn
;      (setq count (+ 1 count))
      (setq outputfilename (format nil "~A.c" file))
      (setq inputfilename (format nil "../alpha-emulator/~A.as" file))
      (format t "compiling ~A~8,11T" inputfilename)
      (format t "--> ~A~%" outputfilename)
      (process-asm-source
       inputfilename
       outputfilename)))

;  (format t "DONE:~%")
;  (format t "~%")
)

(defun load-macros ()

  (load "clisp-support.lisp")
  (load "../emulator/aihead.lisp")
  (load "../emulator/errortbl.lisp")
  (load "../emulator/traps.lisp")
  (load "intrpmac.lisp")

  (load "../alpha-emulator/aistat.lisp")

  (dolist (file
	   '("alphamac"
;	     "intrpmac"
	     "stacklis"
	     "memoryem" "imaclist" "fcallmac" "imacbits"
	     "imacblok" "imaclexi" "imacgene" "imacinst" "imacialu"
	     "imacloop" "imacmath" "imacbind" "imacjosh" "imacarra"
	     "imacpred" "imacsubp" "imactrap"))
    (progn
      (setq filename (format nil "../alpha-emulator/~A.lisp" file))
      (load filename))))

(defun load-macros-old ()
  (load "clisp-support.lisp")
  (load "../emulator/aihead.lisp")
  (load "../emulator/errortbl.lisp")
  (load "intrpmac.lisp")
  (load "../alpha-emulator/aistat.lisp")
  (load "../alpha-emulator/alphamac.lisp")
  (load "../alpha-emulator/stacklis.lisp")
  (load "../alpha-emulator/imacloop.lisp")
  (load "../alpha-emulator/fcallmac.lisp")
  (load "../alpha-emulator/memoryem.lisp")
  (load "../alpha-emulator/imactrap.lisp")
  (load "../alpha-emulator/imacmath.lisp")
  (load "../alpha-emulator/imacsubp.lisp")
  (load "../alpha-emulator/imacblok.lisp")
  (load "../alpha-emulator/imacialu.lisp")
  (load "../alpha-emulator/imacbits.lisp")
  (load "../alpha-emulator/imacpred.lisp")
  (load "../alpha-emulator/imacarra.lisp")
  (load "../alpha-emulator/imacgene.lisp")
  (load "../alpha-emulator/imaclist.lisp")
  (load "../alpha-emulator/imacinst.lisp")
  (load "../alpha-emulator/imacbind.lisp"))

(defun add-missing-global-symbols ()

  (dolist (sym
	   '(
	     |ReadRegisterError|
	     |ReadRegisterFP|
	     |ReadRegisterLP|
	     |ReadRegisterSP|
	     |ReadRegisterError|
	     |ReadRegisterStackCacheLowerBound|
	     |ReadRegisterBARx|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterContinuation|
	     |ReadRegisterAluAndRotateControl|
	     |ReadRegisterControlRegister|
	     |ReadRegisterCRArgumentSize|
	     |ReadRegisterEphemeralOldspaceRegister|
	     |ReadRegisterZoneOldspaceRegister|
	     |ReadRegisterChipRevision|
	     |ReadRegisterFPCoprocessorPresent|
	     |ReadRegisterError|
	     |ReadRegisterPreemptRegister|
	     |ReadRegisterIcacheControl|
	     |ReadRegisterPrefetcherControl|
	     |ReadRegisterMapCacheControl|
	     |ReadRegisterMemoryControl|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterStackCacheOverflowLimit|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterMicrosecondClock|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterTOS|
	     |ReadRegisterEventCount|
	     |ReadRegisterBindingStackPointer|
	     |ReadRegisterCatchBlockList|
	     |ReadRegisterControlStackLimit|
	     |ReadRegisterControlStackExtraLimit|
	     |ReadRegisterBindingStackLimit|
	     |ReadRegisterPHTBase|
	     |ReadRegisterPHTMask|
	     |ReadRegisterCountMapReloads|
	     |ReadRegisterListCacheArea|
	     |ReadRegisterListCacheAddress|
	     |ReadRegisterListCacheLength|
	     |ReadRegisterStructureCacheArea|
	     |ReadRegisterStructureCacheAddress|
	     |ReadRegisterStructureCacheLength|
	     |ReadRegisterDynamicBindingCacheBase|
	     |ReadRegisterDynamicBindingCacheMask|
	     |ReadRegisterChoicePointer|
	     |ReadRegisterStructureStackChoicePointer|
	     |ReadRegisterFEPModeTrapVectorAddress|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterStackFrameMaximumSize|
	     |ReadRegisterStackCacheDumpQuantum|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterError|
	     |ReadRegisterConstantNIL|
	     |ReadRegisterConstantT|
	     |WriteRegisterError|
	     |WriteRegisterFP|
	     |WriteRegisterLP|
	     |WriteRegisterSP|
	     |WriteRegisterError|
	     |WriteRegisterStackCacheLowerBound|
	     |WriteRegisterBARx|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterContinuation|
	     |WriteRegisterAluAndRotateControl|
	     |WriteRegisterControlRegister|
	     |WriteRegisterError|
	     |WriteRegisterEphemeralOldspaceRegister|
	     |WriteRegisterZoneOldspaceRegister|
	     |WriteRegisterError|
	     |WriteRegisterFPCoprocessorPresent|
	     |WriteRegisterError|
	     |WriteRegisterPreemptRegister|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterStackCacheOverflowLimit|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterTOS|
	     |WriteRegisterEventCount|
	     |WriteRegisterBindingStackPointer|
	     |WriteRegisterCatchBlockList|
	     |WriteRegisterControlStackLimit|
	     |WriteRegisterControlStackExtraLimit|
	     |WriteRegisterBindingStackLimit|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterListCacheArea|
	     |WriteRegisterListCacheAddress|
	     |WriteRegisterListCacheLength|
	     |WriteRegisterStructureCacheArea|
	     |WriteRegisterStructureCacheAddress|
	     |WriteRegisterStructureCacheLength|
	     |WriteRegisterDynamicBindingCacheBase|
	     |WriteRegisterDynamicBindingCacheMask|
	     |WriteRegisterChoicePointer|
	     |WriteRegisterStructureStackChoicePointer|
	     |WriteRegisterFEPModeTrapVectorAddress|
	     |WriteRegisterError|
	     |WriteRegisterMappingTableCache|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     |WriteRegisterError|
	     ))
    (add-global-label-symbol sym)))


(defun build ()
;  (load-macros-old)
  (load-macros)
;;   (defmacro define-procedure (name (&rest args) &body body &environment env)
;;     (let ((*function-being-processed* name))
;;       `((start ,name ,(length args))
;; ;      (label ,name)
;; 	(func-label ,name)
;; 	,@(collecting-function-epilogue body env)
;; 	(end ,name))))

  (setq *gensym-counter* 6022)
  (fix-passthrus)
  (add-missing-global-symbols)
  (create-output-files)
)

(build)

;(process-asm-source "input1" "output")
;(process-asm-source "../alpha-emulator/ifunhead.as" "output1")
;(process-asm-source "../alpha-emulator/idispat.as" "output2")
